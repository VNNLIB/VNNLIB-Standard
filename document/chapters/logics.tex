
\chapter{Logics}
\label{sec:query_categories}

\section{Introduction}

Inputs and outputs of operators are \emph{tensors}, i.e.,
multidimensional arrays over some domain, usually numerical. 
If we let $\mathbb{D}$ be any such domain, a $k$-dimensional 
tensor on $\mathbb{D}$ is denoted as $x \in \mathbb{D}^{n_1 
	\times \ldots \times n_k}$.
For example, a vector of $n$ real numbers is a 1-dimensional
tensor $x \in \mathbb{R}^n$, whereas a matrix of $n \times n$ 
Booleans is a 2-dimensional tensor $x \in \mathbb{B}^{n 
	\times n}$ with $\mathbb{B} = \{0, 1\}$. A specific element 
of a tensor can be singled-out via \emph{subscripting}. 

Given a $k$-dimensional tensor $x \in \mathbb{D}^{n_1 \times 
	\ldots \times n_k}$, the element $x_{i_1, \ldots, i_k} \in 
	\mathbb{D}$ is a scalar corresponding to the indexes 
${i_1, \ldots, i_k}$. For example, in a vector of real numbers 
$x \in \mathbb{R}^n$, $x_1$ is the first element, $x_2$ the second 
and so on. In a matrix of Boleans $x \in \mathbb{B}^{n \times
  n}$, $x_{1,1}$ is the first element of the first row, $x_{2,1}$ 
is the first element of the second and so on.

An \emph{operator} $f$ is a function on tensors 
$f: \mathbb{D}^{n_{1} \times n_h} \to \mathbb{D}^{m_{1} \times m_k}$
where $h$ is the dimension of the input tensor and $k$ is the 
dimension of the output tensor. Given a set $F = \{f_1, \ldots, 
	f_p\}$ of $p$ operators, a \emph{feedforward neural network}
is a function $\nu = f_p(f_{p-1}(\ldots f_2(f_1(x))\ldots))$ obtained
through the composition of the operators in $F$ assuming that the 
dimensions of their inputs and outputs are \emph{compatible}, i.e.,
if the  output of $f_i$ is a $k$-dimensional tensor, then the input
of $f_{i+1}$ is also a $k$-dimensional tensor, for all $1 \leq i < p$.

Given a neural network $\nu : \mathbb{D}^{n_{1} \times n_h} \to
\mathbb{D}^{m_{1} \times m_k}$ built on the set of operators $\{f_1,
\ldots, f_p\}$, let $x \in \mathbb{D}^{n_{1} \times n_h}$ denote
the input of $\nu$ and $y_1, \ldots, y_p$ denote the outputs of the
operators $f_1, \ldots, f_p$ --- therefore $y_p$ is also the output
$y$ of $\nu$. We assume that, in general, a \emph{property} is a first
order formula $P(x, y_1, \ldots y_p)$ which should be satisfied given 
$\nu$.


\usetikzlibrary{
    arrows.meta,    % For arrow styles
    positioning,    % For relative positioning of nodes (e.g., below=of)
    shapes.geometric, % For shapes like rounded rectangles
    trees           % For drawing tree structures
}

\tikzset{
    % Style for the logic identifiers - reduced padding and height
    logic/.style={
        draw, 
        thick, 
        rectangle, 
        rounded corners=2pt, 
        fill=blue!10, 
        align=center, 
        minimum height=2.3em, %<-- Reduced height
        inner sep=3pt,       %<-- Reduced internal padding
        font=\small\ttfamily
    },
    % Style for the main category titles
    category/.style={
        font=\bfseries,
        align=center
    },
    % Style for the connecting arrows
    arrow/.style={
        ->,
        thick,
        >=Stealth
    }
}

\begin{figure}
    \centering
    \caption{The VNN-LIB Capability Hierarchy}
    \label{fig:vnnlib_capabilities}
    
    % This command scales the content to the text width, maintaining aspect ratio
    \resizebox{\textwidth}{!}{%
        \begin{tikzpicture}[
            node distance=1cm and 1cm % Vertical and horizontal spacing
        ]
    
        % --- Define the four main category titles in a 2x2 grid ---
        
        % --- TOP ROW ---
        \node (theories_title) [category] at (0,0) {Theories};
        \node (arch_title)     [category] at (8,0) {Architecture};
        
        % --- BOTTOM ROW ---
        \node (arith_title)    [category] at (0,-7cm) {Arithmetic Complexity};
        \node (ortho_title)    [category] at (8,-7cm) {Orthogonal Logic};

        % --- Draw the tree for Theories (Flowing UP) ---
        \node (float_cat) [logic, below=of theories_title, xshift=1.5cm]  {FLOAT};
        \node (f16)       [logic, below=of float_cat, xshift=-1.2cm] {FLOAT16};
        \node (f32)       [logic, below=of float_cat, xshift=1.2cm] {FLOAT32};
        \node (real)      [logic, left=of float_cat] {REAL};
        % Arrows
        \draw[arrow] (f16.north) -- (float_cat.south);
        \draw[arrow] (f32.north) -- (float_cat.south);

        % --- Draw the tree for Architecture (Flowing UP) ---
        \node (csp) [logic, below=of arch_title] {[CSP] (Constraint Satisfaction)};
        \node (fra) [logic, below=of csp]  {[FRA] (Forward Reachability)};
        % Arrow
        \draw [arrow] (fra) -- (csp);

        % --- Draw the tree for Arithmetic Complexity (Flowing UP) ---
        \node (poly)     [logic, below=of arith_title] {POLY};
        \node (linear)   [logic, below=of poly] {LINEAR};
        \node (bounds)   [logic, below=of linear]   {BOUNDS};
        % Arrows
        \draw [arrow] (bounds) -- (linear);
        \draw [arrow] (linear) -- (poly);

        % --- Draw the tree for Orthogonal Logic ---
        \node (strict) [logic, below=of ortho_title] {SI (Strict Inequality)};
        
        \end{tikzpicture}
    }%
\end{figure}

\section{Verifier Architecture}\label{sec:arch}

\subsection*{Constraint Satisfaction Problems}\label{sec:csp}

\subsection*{Forward Reachability Analysis}\label{sec:fra}

More formally, given $p$ bounded sets $X_1, \ldots, X_p$ in $I$ 
such that $\Pi = \bigcup_{i=1}^p X_i$ and $s$ bounded sets $Y_1, 
\ldots, Y_s$ in $O$ such that $\Sigma = \bigcup_{i=1}^s Y_i$, we wish
to prove that  
\begin{equation}
	\label{eq:verif}
	\forall x \in \Pi \rightarrow \nu(x) \in \Sigma.
\end{equation}
The definition of the property given in equation (\ref{eq:verif})
consists of a \textit{pre-}condition $x \in \Pi$ and a 
\textit{post-}condition $\nu(x) \in \Sigma$. The 
\textit{pre-}condition encodes the bounds of the input space, i.e.,
bounds the variables that are fed to the network, and the 
\textit{post-}condition defines the safe zone, outside which the 
verification task fails.

\section{Theories}

\subsection*{Floating Point Arithmetic}

\subsection*{Real Arithmetic}

\section{Arithmetic Complexity}

\subsection*{Polynomial Complexity}

\subsection*{Linear Complexity}

\subsection*{Bounds}

\section{Orthogonal Logic}

\subsection*{Strict Inequality}

