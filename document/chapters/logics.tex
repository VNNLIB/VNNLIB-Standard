\tikzset{
    % Style for the logic identifiers - reduced padding and height
    theory/.style={
        draw, 
        thick, 
        rectangle, 
        rounded corners=2pt, 
        fill=blue!10, 
        align=center, 
        minimum height=2.3em, %<-- Reduced height
        inner sep=3pt,       %<-- Reduced internal padding
        font=\small\ttfamily
    },
    dtheory/.style={
    		theory,
		text width=5cm    
    },
    % Style for the main category titles
    category/.style={
        font=\bfseries,
        align=center
    },
    % Style for the connecting arrows
    arrow/.style={
        ->,
        thick,
        >=Stealth
    }
}
   

\chapter{Theories and Logics}
\label{sec:theories-logics}

The query language described in Chapter~\ref{sec:specification_language} is relatively expressive. However, in practice very few solvers are capable of handling the full set of definable queries.  To address this, the \vnnlib{} standard takes a similar approach to SMT-LIB by using the notion of \emph{theories}, \emph{theory sets} and \emph{logics} to define subsets of the language.

Each theory represents a particular syntactic restriction on the query language, while a theory set represents a set of related theories that are partially ordered under the inclusion relation. A logic is constructed by selecting exactly one theory from each theory set, and therefore represents a particular subset of the query language supported by a particular verifier. 
By reporting the theories supported, a solver can precisely describe the subset of the query language it supports. The formal reporting mechanism is introduced in Chapter~\ref{sec:global_capabilities}.

\section{Theories and Theory Sets}

There are 6 theory sets in total:
\begin{enumerate}
\item \textbf{Hidden nodes}: Are queries with hidden node declarations  are supported?
\item \textbf{Multiple networks}: Are queries with more than one network declaration are supported?
\item \textbf{Multiple input/output nodes}: Are queries with network declarations that declare more than one input/output node  are supported?
\item \textbf{Multi-node comparisons}: Are queries that contain constraints relating variables from more than one ONNX node are supported?
\item \textbf{Arithmetic complexity}: What level of mathematical complexity of constraints are supported (e.g. bounds, linear, polynomial)?
\item \textbf{Datatypes}: What datatypes are supported (e.g. 32-bit floats, reals)?
\end{enumerate}
The following sections examine each of these theory sets in more detail.

\subsection{Hidden Nodes}
\label{sec:hidden-nodes}

\begin{figure}[h]
\centering
\begin{tikzpicture}
   \node (h) [theory] {\h \\ (Hidden nodes)};
   \node (nh) [theory, left=of h, xshift=-1.2cm]  {\nh \\ (No hidden nodes)};

   \draw [arrow] (nh) -- (h);
\end{tikzpicture}
\caption{The \hiddenNodes{} theory set}
\label{fig:hidden-nodes-theory-set}
\end{figure}

Some solvers do not support reasoning about hidden nodes. The \hiddenNodes{} theory set therefore contains two theories \nh{} and \h{}, representing respectively queries that do not hidden nodes declarations, and queries that may contain hidden node declarations. Therefore \nh{} is a subset of \h{}. For example the following query is a member of both \nh{} and \h{}:

\begin{code}[style=lbnf]
(declare-network f
    (declare-input  X float32 [1])
    (declare-output Y float32 [1])
)
\end{code}

while the following is only a member of \h{}:

\begin{code}[style=lbnf]
(declare-network f
    (declare-input  X float32 [1])
    (declare-hidden H float32 [1] "hidden")
    (declare-output Y float32 [1])
)
\end{code}

\subsection{Multiple Inputs/Outputs}
\label{sec:multiple-inputs-outputs}

\begin{figure}[h]
\centering
\begin{tikzpicture}
   \node (mio) [theory] {\mio{} \\ (Multiple inputs and outputs)};
   \node (sio) [theory, left=of mio]  {\sio{} \\ (Single input and output)};

   \draw [arrow] (sio) -- (mio);
\end{tikzpicture}
\caption{The \multiIO{} theory set}
\label{fig:multiple-inputs-outputs-set}
\end{figure}

Many solvers only support reasoning about networks with a single input and output node. The \multiIO{} theory set therefore contains two theories \sio{} and \mio{}, representing queries that contain network declarations that only contain a single input and output node, and queries that contain network declarations that declare an arbitrary number of inputs and outputs. Therefore \sio{} is a subset of \mio{}. For example the following query is a member of both \sio{} and \mio{}:

\begin{code}[style=lbnf]
(declare-network f
    (declare-input  X float32 [1])
    (declare-output Y float32 [1])
)
\end{code}

but the following query is only a member of \mio{}:

\begin{code}[style=lbnf]
(declare-network f
    (declare-input  X1 float32 [1])
    (declare-input  X2 float32 [1])
    (declare-output Y  float32 [1])
)
\end{code}

\subsection{Multiple Networks}
\label{sec:multiple-networks}

\begin{figure}[h]
\centering
\begin{tikzpicture}
   \node (snet) [theory]  {\snet{} \\ (Single network)};
   \node (mnet) [theory, right=of snet, xshift=5em] {\mnet{} \\ (Multiple networks)};
   \node (minet) [theory, below=of mnet] {\minet{} \\ (Multiple  isomorphic networks)};
   \node (menet) [theory, left=of minet, below=of snet] {\menet{} \\ (Multiple equal networks)};

   \draw [arrow] (snet) -- (mnet);
   \draw [arrow] (minet) -- (mnet);
   \draw [arrow] (menet) -- (minet);
\end{tikzpicture}
\caption{The \multiNetwork{} theory set}
\label{fig:multiple-networks-theory-set}
\end{figure}

Some solvers only support reasoning about a single network or are specialised to reason about equal or isomorphic networks. The \multiNetwork{} theory set therefore contains four theories \snet{}, \menet{}, \minet{} and \mnet{}. \snet{} contains queries that have a single network declaration while \mnet{} contains queries that have an arbitrary number of network declarations. For example the following query is a member of \snet{}:

\begin{code}[style=lbnf]
(declare-network f
    (declare-input  X float32 [1])
    (declare-output Y float32 [1])
)
\end{code}

and the following query is only a member of \mnet{}:

\begin{code}[style=lbnf]
(declare-network f
    (declare-input  X float32 [1])
    (declare-output Y float32 [1])
)
(declare-network g
    (declare-input  U float32 [1])
    (declare-output W float32 [1])
)
\end{code}

The theory \menet{} contains queries that have multiple network declarations where all but one contain an \texttt{equal-to} declaration.
\minet{} contains queries that have multiple network declarations where all but one contains either an \texttt{equal-to} or \texttt{isomorphic-to} declaration.


\subsection{Multiple Node Comparisons}
\label{sec:multi-node-comparisons}

\begin{figure}[h]
\centering
\begin{tikzpicture}
   \node (mnc) [theory] {\mnc{} \\ (Multi-node comparisons)};
   \node (snc) [theory, left=of mnc]  {\snc{} \\ (Single node comparisons)};

   \draw [arrow] (snc) -- (mnc);
\end{tikzpicture}
\caption{The \multiComparison{} theory set}
\label{fig:multi-node-comparisons-theory-set}
\end{figure}

Many solvers are based on some variant of abstract interpretation or reachability analysis where an over-approximation of the set of reachable values is computed for each layer in turn.
One consequence of this is that they cannot easily verify queries that contain a comparison involving variables from different nodes in the same network.

The \multiComparison{} theory set therefore contains two theories \snc{} and \mnc{}, representing queries that contain comparisons that do not reference variables from different nodes of the same network, and queries that may contain such comparisons respectively. Therefore \snc{} is a subset of \mnc{}. For example, consider queries that declare the following networks:

\begin{code}[style=lbnf]
(declare-network f
    (declare-input  X float32 [2])
    (declare-output Y float32 [1])
)

(declare-network g
    (declare-input  A float32 [2])
    (declare-hidden H float32 [1] "hidden")
    (declare-output B float32 [1])
)
\end{code}

\noindent then queries containing the following comparisons all belong to both \snc{} and \mnc{}:

\begin{code}[style=lbnf]
(<= (+ X[0] X[1]) 0.1)
(<= Y[0] 0.1)
(<= H[0] 0.5)
(== Y[0] A[0])
\end{code}

\noindent Note in particular, the last comparison is still allowed even through it references multiple different nodes as they belong to different networks. 

However, the following comparisons only belong to \mnc{}:

\begin{code}[style=lbnf]
(<= (+ X[0] Y[0]) 0.1)
(<= H[0] A[1])
(== B[0] H[0])
\end{code}

\subsection{Arithmetic Complexity}
\label{sec:arithmetic-complexity}

\begin{figure}[h]
\centering
\begin{tikzpicture}
   \node (poly)     [theory] {\poly{} \\ (Polynomial arithmetic)};
   \node (linear)   [theory, above left=of poly, xshift=6em] {\lin{} \\ (Linear arithmetic)};   
   \node (cout)   [theory, below left=of linear, xshift=6em] {\cout{} \\ (Output comparisons)};
   \node (bounds)   [theory, above left=of cout, xshift=6em]   {\bnd{} \\ (Bounded variables)};
   
   \draw [arrow] (bounds) -- (cout);
   \draw [arrow] (cout) -- (linear);
   \draw [arrow] (linear) -- (poly);  
\end{tikzpicture}
\caption{The ``Arithmetic complexity'' theory set.}
\label{fig:arithmetic-complexities}
\end{figure}

The more complex the arithmetic constraints the more computationally expensive the verification is. Therefore, the \arithComplexity{} query set is used to restrict the complexity of the arithmetic constraints by dividing them into the following theories:

\begin{enumerate}
\item \textbf{\bnd{}} - 
The simplest level of arithmetic complexity, which restricts query assertions to equalities or inequalities that relate single variables to constants. For example, the following assertions live within \bnd{}:

\begin{code}[style=lbnf]
(assert (and (<= X[0] 1.0) (<= X[0] 1.0)))
(assert (>= Y[0] 0.5))
\end{code}

\item \textbf{\cout{}} - 
The next level allows assertions to perform simple comparisons between multiple hidden or output variables, but maintains the restriction that query assertions over input variables must be equalities or inequalities that relate a single variable to a constant. For example, the following assertions live within \cout{} but not \bnd{}:

\begin{code}[style=lbnf]
(assert (and (<= X[0] 1.0) (<= X[0] 1.0)))
(assert (>= Y[0] Y[1]))
\end{code}

\item \textbf{\lin{}} - Linear arithmetic restricts query assertions to linear expressions over the variables representing inputs, outputs or hidden nodes. For example, the following assertion belongs in \lin{} but not in \cout{} e.g. 

\begin{code}[style=lbnf]
(assert (<= (+ (* 0.5 X[0]) (* 0.75 X[1])) 1.0))
(assert (>= (+ Y[0] Y[1]) 0.5))
\end{code}

\item \textbf{\poly{}} - Polynomial arithmetic restricts query assertions to polynomial expressions over the variables representing inputs, outputs or hidden nodes. 
For example, the following assertion belongs in \poly{} but not in \lin{}

\begin{code}[style=lbnf]
(assert (<= (* X[0] X[1]) 1.0)
(assert (>= (+ Y[0] Y[1]) 0.5))
\end{code}

\end{enumerate}


\subsection{Element Types}
\label{sec:element-types}

\begin{figure}[h]
\centering
\begin{tikzpicture}    
    \node (onnx) [category] at (-2,0) {Theory element types};
    
    \draw [dashed] (1.3,0.5) -- (1.3,-8);
    
    \node (other) [category] at (5,0) {Additional element types};
    
    
   \node (d)   [theory, below=of onnx, xshift=-1.5cm]  {\theory{FLOAT64}};
   \node (f)   [theory, below=of d]  {\theory{FLOAT32}};
   \node (f16)   [theory, below=of f]  {\theory{FLOAT16}};
   \node (dots1)   [below=of f16]  {\textbf{...}};
   
  \node (i64)   [theory, below=of onnx, xshift=1.5cm]  {\theory{INT64}};
   \node (i32)   [theory, below=of i64]  {\theory{INT32}};
   \node (i16)   [theory, below=of i32]  {\theory{INT16}};
   \node (dots2)   [below=of i16]  {\textbf{...}};
   
   \node (real)        [theory, below=of other] {REAL};
\end{tikzpicture}
\caption{The ``Tensor element types'' theory set. Note that the element type theories on the left hand side are representative only, as they will depend on the network theory $\networkTheoryVar$ being used.}
\label{fig:element-type-theories}
\end{figure}

Every tensor element type in the network theory $\networkTheoryVar$ is associated with a \vnnlib{} theory of the same name.
As the \vnnlib{} standard supports the ONNX, the ONNX format supports a range of different \href{https://onnx.ai/onnx/repo-docs/IR.html#tensor-element-types}{tensor element types} as discussed in Section~\ref{sec:onnx_overview}. Figure~\ref{fig:element-type-theories}. A solver supporting a particular element type theory means that it supports variable declarations that use that type. For example, the following network declaration belongs to the \theory{float16} theory:

\begin{code}[style=lbnf]
(declare-network f
    (declare-input  X float16 [2])
    (declare-output Y float16 [1])
)
\end{code}

Of course, the same network declaration can contain inputs and outputs of different ONNX element types. In such a case, the query is only supported if the solver supports all of the theories associated with the element types (and of course the ONNX operators used internally to convert between the types).

\textbf{Note}: the ONNX specification has two different sets of names for the element types: \href{https://onnx.ai/onnx/repo-docs/IR.html#tensor-element-types}{Set 1} and \href{https://onnx.ai/onnx/intro/concepts.html#element-type}{Set 2}. \vnnlib{} uses the former set of names.

\section{Logics}

Logics are therefore composed by the combination of theories from each of the above orthogonal categories. For example, the logic:
\begin{center}
\logic{\h{}-\snet{}-\sio{}-\mnc{}-\lin{}-\theory{FLOAT32}} 
\end{center}
represents the class of queries that contain hidden nodes declarations, a single network declaration with a single input and output using the 32-bit floats, with linear comparisons between arbitrary declared variables.
The set of logics is referred to as $\logicSet$. 

Concretely, given a network theory $\networkTheoryVar$ and a logic $\logicVar \in \logicSet$, a solver $s$ for that logic is a function with the following type:
\begin{equation*}
s : \mgrammar{<query>} \rightarrow [\mgrammar{<model>}] \rightarrow \mathbb{B}
\end{equation*}
where $\forall \queryVar, \networkImplementationSet . \:\: (\queryVar \in \logicVar) \wedge (\vdash \networkImplementationSet : \queryVar) \implies s(\queryVar, \networkImplementationSet) = \semQuery{\queryVar, \networkImplementationSet}$