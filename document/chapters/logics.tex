\tikzset{
    % Style for the logic identifiers - reduced padding and height
    theory/.style={
        draw, 
        thick, 
        rectangle, 
        rounded corners=2pt, 
        fill=blue!10, 
        align=center, 
        minimum height=2.3em, %<-- Reduced height
        inner sep=3pt,       %<-- Reduced internal padding
        font=\small\ttfamily
    },
    dtheory/.style={
    		theory,
		text width=5cm    
    },
    % Style for the main category titles
    category/.style={
        font=\bfseries,
        align=center
    },
    % Style for the connecting arrows
    arrow/.style={
        ->,
        thick,
        >=Stealth
    }
}
   

\chapter{Theories and Logics}
\label{sec:theories-logics}

The query language described in Chapter~\ref{sec:specification_language} is is relatively expressive. However, in practice very few verifiers are capable of handling the full range of queries it permits.  To address this, the \vnnlib{} standard takes a similar approach to SMTLib by using the notion of \emph{logics} and \emph{theories} to define subsets of the language.

Each \emph{theory} represents a particular syntactic restriction on the query language, and a \emph{theory set} represents a set of related restrictions that are partially ordered under the inclusion relation. A \emph{logic} represents a subset of the query language and is constructed by selecting exactly one theory from the list of orthogonal theory sets. 
By reporting the theories supported, a verifier can precisely describe the subset of the query language it supports. The formal reporting mechanism is introduced in Chapter~\ref{sec:global_capabilities}.

\section{Theory sets}

The currently supported theory sets are:
\begin{enumerate}
\item \textbf{Hidden nodes}: Are queries with hidden node declarations  are supported.
\item \textbf{Multiple networks}: Are queries with more than one network declaration are supported.
\item \textbf{Multiple input/output nodes}: Are queries with network declarations that declare more than one input/output node  are supported.
\item \textbf{Multi-node comparisons}: Are queries that contain constraints relating variables from more than one ONNX node are supported.
\item \textbf{Arithmetic complexity}: What level of mathematical complexity of constraints are supported (e.g. bounds, linear, polynomial). 
\item \textbf{Datatypes}: What datatypes are supported (e.g. 32-bit floats, reals).
\end{enumerate}
The following sections examine each of these theory sets in more detail.

\subsection{Hidden nodes}
\label{sec:hidden-nodes}

\begin{figure}[h]
\centering
\begin{tikzpicture}
   \node (h) [theory] {\h \\ (Hidden nodes)};
   \node (nh) [theory, left=of h, xshift=-1.2cm]  {\nh \\ (No hidden nodes)};

   \draw [arrow] (nh) -- (h);
\end{tikzpicture}
\caption{The ``Hidden nodes'' theory set}
\label{fig:hidden-nodes-theory-set}
\end{figure}

Some neural network verifiers do not support reasoning about hidden nodes. The ``Hidden nodes'' theory set therefore contains two theories \nh{} and \h{}, representing queries that contain networks that do not declare hidden nodes, and queries that contain networks that declare hidden nodes. Therefore \nh{} is a subset of \h{}. For example the following query is a member of both \nh{} and \h{}:

\begin{code}[style=lbnf]
(declare-network f
    (declare-input  X float32 [1])
    (declare-output Y float32 [1])
)
\end{code}

but the following query is only a member of \h{}:

\begin{code}[style=lbnf]
(declare-network f
    (declare-input  X float32 [1])
    (declare-hidden H float32 [1] "hidden")
    (declare-output Y float32 [1])
)
\end{code}

\subsection{Multiple networks}
\label{sec:multiple-networks}

\begin{figure}[h]
\centering
\begin{tikzpicture}
   \node (mnet) [theory] {\mnet{} \\ (Multiple networks)};
   \node (snet) [theory, left=of mnet]  {\snet{} \\ (Single network)};

   \draw [arrow] (snet) -- (mnet);
\end{tikzpicture}
\caption{The ``Multiple networks'' theory set}
\label{fig:multiple-networks-theory-set}
\end{figure}

Many neural network verifiers only support reasoning about a single network. The ``Multiple networks'' theory set therefore contains two theories \snet{} and \mnet{}, representing queries that contain a single network and queries that an arbitrary number of network declarations. Therefore \snet{} is a subset of \mnet{}. For example the following query is a member of both \snet{} and \mnet{}:

\begin{code}[style=lbnf]
(declare-network f
    (declare-input  X float32 [1])
    (declare-output Y float32 [1])
)
\end{code}

but the following query is only a member of \mnet{}:

\begin{code}[style=lbnf]
(declare-network f
    (declare-input  X float32 [1])
    (declare-output Y float32 [1])
)
(declare-network g
    (declare-input  U float32 [1])
    (declare-output W float32 [1])
)
\end{code}

\subsection{Multiple inputs/output}
\label{sec:multiple-inputs-outputs}

\begin{figure}[h]
\centering
\begin{tikzpicture}
   \node (mio) [theory] {\mio{} \\ (Multiple inputs and outputs)};
   \node (sio) [theory, left=of mnet, xshift=-1.2cm]  {\sio{} \\ (Single input and output)};

   \draw [arrow] (sio) -- (mio);
\end{tikzpicture}
\caption{The ``Multiple inputs/outputs'' theory set}
\label{fig:multiple-inputs-outputs-set}
\end{figure}

Many neural network verifiers only support reasoning about networks with a single input and output node. The ``Multiple inputs/outputs'' theory set therefore contains two theories \sio{} and \mio{}, representing queries that contain network declarations that only contain a single input and output node, and queries that contain network declarations that declare an arbitrary number of inputs and outputs. Therefore \sio{} is a subset of \mio{}. For example the following query is a member of both \sio{} and \mio{}:

\begin{code}[style=lbnf]
(declare-network f
    (declare-input  X float32 [1])
    (declare-output Y float32 [1])
)
\end{code}

but the following query is only a member of \mio{}:

\begin{code}[style=lbnf]
(declare-network f
    (declare-input  X1 float32 [1])
    (declare-input  X2 float32 [1])
    (declare-output Y  float32 [1])
)
\end{code}

\subsection{Multiple node comparisons}
\label{sec:multi-node-comparisons}

\begin{figure}[h]
\centering
\begin{tikzpicture}
   \node (mnc) [theory] {\mnc{} \\ (Multi-node comparisons)};
   \node (snc) [theory, left=of mnc]  {\snc{} \\ (Single node comparisons)};

   \draw [arrow] (snc) -- (mnc);
\end{tikzpicture}
\caption{The ``Multiple node comparisons'' theory set}
\label{fig:multi-node-comparisons-theory-set}
\end{figure}

Many verifiers are based on some variant of abstract interpretation or reachability analysis where an over-approximation of the set of reachable values is computed for each layer in turn.
One consequence of this is that they cannot easily verify queries that contain a comparison involving variables from different nodes in the same network.

The ``Multiple node comparisons'' theory set therefore contains two theories \snc{} and \mnc{}, representing queries that contain comparisons that do not reference variables from different nodes of the same network, and queries that may contain such comparisons respectively. Therefore \snc{} is a subset of \mnc{}. For example, consider queries that declare the following networks:

\begin{code}[style=lbnf]
(declare-network f
    (declare-input  X float32 [2])
    (declare-output Y float32 [1])
)

(declare-network g
    (declare-input  A float32 [2])
    (declare-hidden H float32 [1] "hidden")
    (declare-output B float32 [1])
)
\end{code}

\noindent then queries containing the following comparisons all belong to both \snc{} and \mnc{}:

\begin{code}[style=lbnf]
(<= (+ X[0] X[1]) 0.1)
(<= Y[0] 0.1)
(<= H[0] 0.5)
(== Y[0] A[0])
\end{code}

\noindent Note in particular, the last comparison is still allowed even through it references multiple different nodes as they belong to different networks. 

However, the following comparisons only belong to \mnc{}:

\begin{code}[style=lbnf]
(<= (+ X[0] Y[0]) 0.1)
(<= H[0] A[1])
(== B[0] H[0])
\end{code}

\subsection{Arithmetic complexity}
\label{sec:arithmetic-complexity}

\begin{figure}[h]
\centering
\begin{tikzpicture}
   \node (poly)     [theory] {\poly{} \\ (Polynomial arithmetic)};
   \node (linear)   [theory, left=of poly] {\lin{} \\ (Linear arithmetic)};
   \node (bounds)   [theory, left=of linear]   {\bnd{} \\ (Bounds)};
   
   \draw [arrow] (bounds) -- (linear);
   \draw [arrow] (linear) -- (poly);  
\end{tikzpicture}
\caption{The ``Arithmetic complexity'' theory set.}
\label{fig:arithmetic-complexities}
\end{figure}

The more complex the arithmetic constraints the more computationally expensive the verification is. Therefore, the ``Arithmetic complexity'' query set is used to restrict the complexity of the arithmetic constraints by dividing them into three theories:

\begin{enumerate}
\item \textbf{\bnd{}} - 
The simplest level of arithmetic complexity is \bnd{}, which restricts query assertions to equalities or inequalities that relate a single variable representing 
inputs, outputs or hidden nodes to a constant. For example, the following assertions live within \bnd{}:

\begin{code}[style=lbnf]
(assert (and (<= X[0] 1.0) (<= X[0] 1.0)))
(assert (>= Y[0] 0.5))
\end{code}

\item \textbf{\lin{}} - Linear arithmetic restricts query assertions to linear expressions over the variables representing inputs, outputs or hidden nodes. Every query in LIN is also a query in BND. For example, the following assertion belongs in \lin{} but not in \bnd{} e.g. 

\begin{code}[style=lbnf]
(assert (<= (+ (* 0.5 X[0]) (* 0.75 X[1])) 1.0))
\end{code}

\item \textbf{\poly{}} - Polynomial arithmetic restricts query assertions to polynomial expressions over the variables representing inputs, outputs or hidden nodes. 
Every query in POLY is also a query in LIN.
For example, the following assertion belongs in \poly{} but not in \lin{}

\begin{code}[style=lbnf]
(assert (<= (* X[0] X[1]) 1.0)
\end{code}

\end{enumerate}


\subsection{Tensor element types}
\label{sec:element-types}

\subsubsection{ONNX element types}

\begin{figure}[h]
\centering
\begin{tikzpicture}    
    \node (onnx) [category] at (-2,0) {ONNX element types};
    
    \draw [dashed] (1.3,0.5) -- (1.3,-8);
    
    \node (other) [category] at (5,0) {Additional element types};
    
    
   \node (d)   [theory, below=of onnx, xshift=-1.5cm]  {\theory{FLOAT64}};
   \node (f)   [theory, below=of d]  {\theory{FLOAT32}};
   \node (f16)   [theory, below=of f]  {\theory{FLOAT16}};
   \node (dots1)   [below=of f16]  {\textbf{...}};
   
  \node (i64)   [theory, below=of onnx, xshift=1.5cm]  {\theory{INT64}};
   \node (i32)   [theory, below=of i64]  {\theory{INT32}};
   \node (i16)   [theory, below=of i32]  {\theory{INT16}};
   \node (dots2)   [below=of i16]  {\textbf{...}};
   
   \node (real)        [theory, below=of other] {REAL};
\end{tikzpicture}
\caption{The ``Tensor element types'' theory set. Not all ONNX element types are shown.}
\label{fig:element-type-theories}
\end{figure}

As discussed in Section~\ref{sec:onnx_overview} and as seen in Figure~\ref{fig:element-type-theories}, the ONNX format supports a range of different \href{https://onnx.ai/onnx/repo-docs/IR.html#tensor-element-types}{tensor element types} such ``float32''. Every tensor element type in the ONNX specification is associated with a \vnnlib{} theory of the same name. A solver supporting a particular element type theory means that it supports variable declarations that use that type. For example, the following network declaration belongs to the \theory{float16} theory:

\begin{code}[style=lbnf]
(declare-network f
    (declare-input  X float16 [2])
    (declare-output Y float16 [1])
)
\end{code}

Of course, the same network declaration can contain inputs and outputs of different ONNX element types. In such a case, the query is only supported if the solver supports all of the theories associated with the element types (and of course the ONNX operators used internally to convert between the types).

\textbf{Note}: the ONNX specification has two different sets of names for the element types: \href{https://onnx.ai/onnx/repo-docs/IR.html#tensor-element-types}{Set 1} and \href{https://onnx.ai/onnx/intro/concepts.html#element-type}{Set 2}. \vnnlib{} uses the former set of names.

\subsubsection{The `Real' element type}

It is a well-known problem in the community that some solvers assume real semantics and therefore are not sound with respect to the semantics of the various floating point types~\cite{jia2021exploiting}. In order to support such solvers, the specification contains an additional tensor element type `real` and associated theory that does not appear in the ONNX specification.

If a user writes the ``real'' type in their \vnnlib{} query then they are explicitly giving permission for the solver to convert the numeric ONNX types used by the actual ONNX file to an arbitrary internal numeric representation. The user is therefore explicitly acknowledging that the result may be unsound due to floating point imprecision. 

Conversely if user writes an ONNX element type in their \vnnlib{} query then they are explicitly requesting sound analysis. If the solver does not support the ONNX element type in question, then the solver must throw an error. The solver must also throw an error if the types used in the ONNX network provided do not match the ONNX element types written in the query.

\section{Logics}

Logics are therefore composed by the combination of theories from each of the above orthogonal categories. For example, the logic \logic{\h{}-\snet{}-\sio{}-\mnc{}-\lin{}-\theory{FLOAT32}} represents the class of queries that contain hidden nodes declarations, a single network declaration with a single input and output using the 32-bit floats, with linear comparisons between arbitrary declared variables.
