\chapter{Command-line Interface}
\label{sec:solver_interface}

\newcommand{\clOutputOption}[3]{
\paragraph{\texttt{#1}}
\begin{itemize}
    \item \textbf{Description}: #2
    \item \textbf{Output}: #3
    \item \textbf{Example usage}:
\end{itemize}
}

\newcommand{\clOption}[3]{
\paragraph{\texttt{#1}}
\begin{itemize}
    \item \textbf{Description}: #2
    \item \textbf{Example usage}: \texttt{#3}
\end{itemize}
}

\lstdefinestyle{bashcommand}{
	style=bash,
    numbers=none,
    frame=none,
    backgroundcolor=\color{white}
}

\newcommand{\exampleVerifier}{checkNN}

With the growing number of neural network verifiers and their increasing integration into larger toolchains, there is a clear need for a consistent and predictable way to invoke them. A standardised command-line interface (CLI) therefore enables interoperability between verifiers and higher-level tools, facilitates benchmarking and automation, and reduces the burden on users adapting to multiple systems.

This chapter defines the CLI for neural network verifiers that conform to the \vnnlib{} standard. The interface supports querying verifier capabilities, listing supported operations, and running verification tasks with configurable options.

\section{Invocation}

All verifiers adhering to the \vnnlib{} specification should be available as an executable or script invokable by the command line, which will be referred to in this chapter as \texttt{<verifier>}. The general syntax for interacting with the verifier via the CLI is:
\begin{lstlisting}[style=bash]
<verifier>
    [global-options] 
    <command> 
    [command-options] 
    [arguments] 
\end{lstlisting}
Throughout the following sections, \texttt{<...>} is used to indicate required values and \texttt{[...]} is used to indicate optional values. To illustrate the example usages, we will  use an imaginary verifier called \texttt{\exampleVerifier}.

Invoking the verifier will produce output in the format described in the rest of this section. Unless stated otherwise all output should be printed on \texttt{stdout}. Detailed logs, warnings, or error messages must be printed on \texttt{stderr}.
At the moment, the \vnnlib{} standard contains two commands: \emph{verify} and \emph{capabilities}. Compliant verifiers can provide additional other non-standard functionality under different commands. 

\section{Global options}

\vnnlib{} compliant verifiers should implement the following global options:

\clOutputOption
{--name}
{Print the verifier's full name. This can be different from the executable's name and may contain spaces, special characters etc.}
{A string.}
\begin{lstlisting}[style=bash]
%*\exampleVerifier* --name
CheckNeuralNetworks!
\end{lstlisting}

\clOutputOption
{--version}
{Print the verifier's version string. It is strongly recommended that verifiers conform to \href{https://semver.org/}{semantic versioning}.}{A version string.}
\begin{lstlisting}[style=bash]
%*\exampleVerifier* --version
1.0.1
\end{lstlisting}


\section{The \texttt{verify} command}
\label{sec:verify_command}

When invoked with the \texttt{verify} command  the verifier should attempt to determine whether a satisfiable assignment of variables exist for the provided \vnnlib{} query and neural network models.

The general pattern of usage is as follows:
\begin{lstlisting}[style=bash]
<verifier> verify 
  <filepath>
  [--network <name>=<filepath>]
  [--timeout <seconds>]
  [--proto-output <filepath>]
\end{lstlisting}
The first argument should be the path to the \vnnlib{} query file (see Section~\ref{sec:specification_language}), and the verifier should support the following additional options:

\clOption{--network}{This option maps the name of one of the networks declared in the provided \vnnlib{} query file to its implementation as an ONNX model file. When a query refers to multiple networks, this option should be used more than once.}{--network classifier=/a/path/to/a/model.onnx}

\clOption{--timeout}{Maximum time to spend on processing on the query in an integer number of seconds.}{--timeout 10}

\clOption{--proto-output}{Path to a file containing the satisfying assignment found. This is an optional argument that may not be supported by the verifier.}{--proto-output /path/to/output.onnx}

\noindent The initial output of the command should be reported on \texttt{stdout} and should be a single line consisting of one of the following options: 
\begin{itemize}
\item \texttt{timed-out} - The allocated time elapsed before the verification procedure terminated.
\item \texttt{unknown} - The verifier terminated but was unable to definitively prove whether or not the query was unsatisfiable.
\item \texttt{unsat} - The verifier terminated and proved that the query was unsatisfiable.
\item \texttt{sat} - The verifier terminated and proved that the query was satisfiable.
\end{itemize}
If the query is satisfied, the result \texttt{sat} is printed to \texttt{stdout} and the satisfying assignment found is either printed to \texttt{stdout} or written to the file specified by the \texttt{--output} option. 

\section*{ModelProto output format}
An efficient alternative output format for the satisfying assignment is the \texttt{ModelProto} format, which is a binary format used by ONNX. This format can be specified using the \texttt{--proto-output} option. The satisfying assignment is written to one or more \texttt{TensorProto} messages, stored in the \texttt{graph.initializer} field of the \texttt{ModelProto} message. Each \texttt{TensorProto} fully defines the assignment of a variable and contains the variable's name, type (\texttt{TypeProto}), shape (\texttt{ShapeProto}), and values.

\section*{Standard output format}
The default output format for the satisfying assignment is a list of element assignments for each variable in the query. The \texttt{sat} output to \texttt{stdout} should be in the following format:
\begin{lstlisting}[style=bash]
sat
<variable_1_name> <variable_1_type> <variable_1_dimensions>
<value>
<value>
...
<variable_n_name> <variable_n_type> <variable_n_dimensions>
\end{lstlisting}
The variables should be reported in the order that they are declared in the query file. Each assignment is reported on a seperate line, with the elements in row-major order. For example, the result for a \vnnlib{} query that started with the following network declarations:
\begin{lstlisting}[style=bash]
(declare-network f
    (declare-input A Real [2,2])
    (declare-input B Real [1])
    (declare-hidden H Real [1,2])
    (declare-output Y Real [1])
)
(declare-network g
    (declare-input C Real [2,2])
    (declare-output Z Real [1])
)
...
\end{lstlisting}
then the output should be printed in the form:
\begin{lstlisting}[style=bash]
sat
A Real [2,2]
... 
...
...
...
B Real [1]
...
H Real [1,2]
...
...
Y Real [1]
...
C Real [2,2]
...
...
...
...
Z Real [1]
...
\end{lstlisting}
Compliant verifiers may also support additional non-standard arguments to the \texttt{verify} command to affect the internal behaviour of the verification algorithm. However, such additional non-standard arguments must be optional.

\section{The \texttt{supports} command}
\label{sec:global_capabilities}

When invoked with the \texttt{supports} command, the verifier should report the types of queries and networks it is capable of verifying.
These options provide a way for higher-level tools to automatically assess the capabilities of the verifier.

The general pattern of usage is as follows:
\begin{lstlisting}[style=bash]
<verifier> supports <option>
\end{lstlisting}
and the verifier should be able to report the following capabilities:

\subsection{\vnnlib{} capabilities}

\clOutputOption
{--vnnlib-versions}
{Prints a newline-separated pair of the minimum and maximum versions (inclusive) of \vnnlib{} that the verifier supports.}
{Two version strings}
\begin{lstlisting}[style=bash]
%*\exampleVerifier* supports --vnnlib-versions
2.0
2.3
\end{lstlisting}

\subsection{ONNX capabilities}

\clOutputOption
{--proto-output}
{Does the verifier support the \texttt{ModelProto} output format for satisfying assignments?}
{A boolean (\texttt{true} or \texttt{false})}
\begin{lstlisting}[style=bash]
%*\exampleVerifier* supports --proto-output
true
\end{lstlisting}

\clOutputOption
{--onnx-opset-versions}
{Prints a newline-separated pair of the minimum and maximum \href{https://onnxruntime.ai/docs/reference/compatibility.html\#onnx-opset-support}{ONNX opset versions} that the verifier supports.}
{Two version strings}
\begin{lstlisting}[style=bash]
%*\exampleVerifier* supports --onnx-opset-versions
13
19
\end{lstlisting}

\clOutputOption
{--onnx-types}
{Prints a newline-separated list of the ONNX data types that the verifier supports.}
{List of ONNX types}
\begin{lstlisting}[style=bash]
%*\exampleVerifier* supports --onnx-types
REAL
FLOAT32
\end{lstlisting}

\clOutputOption
{--onnx-operators}
{Reports the ONNX operator types (e.g., ``Conv'', ``Relu'', ``Gemm'') that are supported by the verifier. See Section~\ref{sec:models} for more details on the ONNX standard and its operators.}
{A newline-separated list of ONNX operators}
\begin{lstlisting}[style=bash]
%*\exampleVerifier* supports --onnx-operators
Conv
Relu
MatMul
Gemm
Add
Flatten
\end{lstlisting}

\clOutputOption
{--multiple-input-outputs}
{Does the verifier support ONNX networks with multiple input or output nodes? See Section~\ref{sec:complex-networks-decls} for details.}
{A boolean (\texttt{true} or \texttt{false})}
\begin{lstlisting}[style=bash]
%*\exampleVerifier* supports --multiple-inputs-outputs
true
\end{lstlisting}

\subsection{Query capabilities}

\clOutputOption
{--multiple-networks}
{Does the verifier support queries with multiple networks? See Section~\ref{sec:complex-networks-decls} for how to declare multiple networks in a query.}
{A boolean (\texttt{true} or \texttt{false})}
\begin{lstlisting}[style=bash]
%*\exampleVerifier* supports --multiple-networks
false
\end{lstlisting}

\clOutputOption
{--hidden-nodes}
{Does the verifier support queries which refer to hidden nodes in the network? See Section~\ref{sec:complex-networks-decls} for how to declare hidden nodes in a query.}
{A boolean (\texttt{true} or \texttt{false})}
\begin{lstlisting}[style=bash]
%*\exampleVerifier* supports --hidden-nodes
true
\end{lstlisting}

\clOutputOption
{--arithmetic-complexity}
{Prints a list of supported \vnnlib{} logics, indicating the scope of theoretical support. See Section~\ref{sec:arithmetic_complexity} for 
    details on each of the logics (e.g., NRA for non-linear real arithmetic support) that may be represented in \vnnlib{}.
}
{A newline-seperated list of logics.}
\begin{lstlisting}[style=bash]
%*\exampleVerifier* supports --logics
FRA
LINEAR
R
\end{lstlisting}



