\chapter{Command-line Interface}
\label{sec:solver_interface}

\newcommand{\clOutputOption}[3]{
\paragraph{\texttt{#1}}
\begin{itemize}
    \item \textbf{Description}: #2
    \item \textbf{Output}: #3
    \item \textbf{Example usage}:
\end{itemize}
}

\newcommand{\clOption}[3]{
\paragraph{\texttt{#1}}
\begin{itemize}
    \item \textbf{Description}: #2
    \item \textbf{Example usage}: \texttt{#3}
\end{itemize}
}

\lstdefinestyle{bashcommand}{
	style=bash,
    numbers=none,
    frame=none,
    backgroundcolor=\color{white}
}

\newcommand{\exampleVerifier}{checkNN}

With the growing number of neural network verifiers and their increasing integration into larger toolchains, there is a clear need for a consistent and predictable way to invoke them. A standardised command-line interface (CLI) therefore enables interoperability between verifiers and higher-level tools, facilitates benchmarking and automation, and reduces the burden on users adapting to multiple systems.

This chapter defines the CLI for neural network verifiers that conform to the \vnnlib{} standard. The interface supports querying verifier capabilities, listing supported operations, and running verification tasks with configurable options.

\section{Invocation}

All verifiers adhering to the \vnnlib{} specification should be available as an executable or script invokable by the command line, which will be referred to in this chapter as \texttt{<verifier>}. The general syntax for interacting with the verifier via the CLI is:
\begin{lstlisting}[style=bash]
<verifier>
    [global-options] 
    <command> 
    [command-options] 
    [arguments] 
\end{lstlisting}
Throughout the following sections, \texttt{<...>} is used to indicate required values and \texttt{[...]} is used to indicate optional values. To illustrate the example usages, we will  use an imaginary verifier called \texttt{\exampleVerifier}.

Invoking the verifier will produce output in the format described in the rest of this section. Unless stated otherwise all output should be printed on \texttt{stdout}. Detailed logs, warnings, or error messages must be printed on \texttt{stderr}.
At the moment, the \vnnlib{} standard contains two commands: \emph{verify} and \emph{capabilities}. Compliant verifiers can provide additional other non-standard functionality under different commands. 

\section{Global options}

\vnnlib{} compliant verifiers should implement the following global options:

\clOutputOption
{--name}
{Print the verifier's full name. This can be different from the executable's name and may contain spaces, special characters etc.}
{A string.}
\begin{lstlisting}[style=bash]
%*\exampleVerifier* --name
CheckNeuralNetworks!
\end{lstlisting}

\clOutputOption
{--version}
{Print the verifier's version string. It is strongly recommended that verifiers conform to \href{https://semver.org/}{semantic versioning}.}{A version string.}
\begin{lstlisting}[style=bash]
%*\exampleVerifier* --version
1.0.1
\end{lstlisting}


\section{The \texttt{verify} command}
\label{sec:verify_command}

When invoked with the \texttt{verify} command  the verifier should attempt to determine whether a satisfiable assignment of variables exist for the provided \vnnlib{} query and neural network models.

The general pattern of usage is as follows:
\begin{lstlisting}[style=bash]
<verifier> verify 
  <filepath>
  [--network <name>=<filepath>]
  [--timeout <seconds>]
\end{lstlisting}
The first argument should be the path to the \vnnlib{} query file (see Section~\ref{sec:specification_language}), and the verifier should support the following additional options:

\clOption{--network}{This option maps the name of one of the networks declared in the provided \vnnlib{} query file to its implementation as an ONNX model file. When a query refers to multiple networks, this option should be used more than once.}{--network classifier=/a/path/to/a/model.onnx}

\clOption{--timeout}{Maximum time to spend on processing on the query in an integer number of seconds.}{--timeout 10}

\noindent The initial output of the command should be reported on \texttt{stdout} and should be a single line consisting of one of the following options: 
\begin{itemize}
\item \texttt{timed-out} - The allocated time elapsed before the verification procedure terminated.
\item \texttt{unknown} - The verifier terminated but was unable to definitively prove whether or not the query was unsatisfiable.
\item \texttt{unsat} - The verifier terminated and proved that the query was unsatisfiable.
\item \texttt{sat} - The verifier terminated and proved that the query was satisfiable.
\end{itemize}
If the result is \texttt{sat}, the satisfying assignment found should be printed on the immediately following lines in the following format:
\begin{lstlisting}[style=bash]
sat
<variable_1>=<value>
<variable_2>=<value>
...
<variable_n>=<value>
\end{lstlisting}
The variables should be reported in the order that they are declared in the query file. For example, the result for a \vnnlib{} query that started with the following network declarations:
\begin{lstlisting}[style=bash]
(declare-network f
    (declare-input  A float32 [2,2])
    (declare-input  B float32 [1])
    (declare-hidden H float32 [1,2] "hidden")
    (declare-output Y float32 [1])
)
(declare-network g
    (declare-input  C float32 [2,2])
    (declare-output Z float32 [1])
)
...
\end{lstlisting}
then the output should be printed as:
\begin{lstlisting}[style=bash]
sat
A[0,0]=...
A[0,1]=...
A[1,0]=...
A[0,0]=...
B[0]=...
H[0,0]=...
H[0,1]=...
Y[0]=...
C[0,0]=...
C[0,1]=...
C[1,0]=...
C[0,0]=...
Z[0]=...
\end{lstlisting}
Compliant verifiers may also support additional non-standard arguments to the \texttt{verify} command to affect the internal behaviour of the verification algorithm. However, such additional non-standard arguments must be optional.

\mnote{TODO: Is there a way to output these tensors more efficiently in a standardised format?}

\section{The \texttt{supports} command}
\label{sec:global_capabilities}

When invoked with the \texttt{supports} command, the verifier should report the types of queries and networks it is capable of verifying.
These options provide a way for higher-level tools to automatically assess the capabilities of the verifier.

The general pattern of usage is as follows:
\begin{lstlisting}[style=bash]
<verifier> supports <option>
\end{lstlisting}
and the verifier should be able to report the following capabilities:

\subsection{\vnnlib{} capabilities}

\clOutputOption
{--vnnlib-versions}
{Prints a newline-separated pair of the minimum and maximum versions (inclusive) of \vnnlib{} that the verifier supports.}
{Two version strings}
\begin{lstlisting}[style=bash]
%*\exampleVerifier* supports --vnnlib-versions
2.0
2.3
\end{lstlisting}

\subsection{ONNX capabilities}

\clOutputOption
{--onnx-opset-versions}
{Prints a newline-separated pair of the minimum and maximum \href{https://onnxruntime.ai/docs/reference/compatibility.html\#onnx-opset-support}{ONNX opset versions} that the verifier supports.}
{Two version strings}
\begin{lstlisting}[style=bash]
%*\exampleVerifier* supports --onnx-opset-versions
13
19
\end{lstlisting}

\clOutputOption
{--onnx-element-types}
{Prints a newline-separated list of the element types that the verifier supports. See Section~\ref{sec:element-types} for details.}
{List of ONNX types}
\begin{lstlisting}[style=bash]
%*\exampleVerifier* supports --onnx-element-types
float64
float32
float16
real
\end{lstlisting}
\textbf{Note}: as discussed in Section~\ref{sec:element-types}, in order for a solver to report that it supports an ONNX element type, then there must be a strong reason to believe that its analysis is sound with respect to that element type. If unsound, or the soundness is unknown then the solver should only report that it supports the `real' type.

\clOutputOption
{--onnx-operators}
{Reports the ONNX operators (e.g., \texttt{Conv}, \texttt{Relu}, \texttt{Gemm}) that are supported by the verifier. See Section~\ref{sec:models} for more details on the ONNX standard and its operators. 
}
{A newline-separated list of lines, where each line contains the name of an ONNX operator followed by a possibly empty space-separated list of ONNX element types. If the list is empty, then the verifier is assumed to support the operator for all element types it reports via the \texttt{supports --onnx-element-types} command.
}
\begin{lstlisting}[style=bash]
%*\exampleVerifier* supports --onnx-operators
Conv float64 float32
Relu float64 float32
MatMul
Gemm
Add float64 float32 int64 int32
Flatten
\end{lstlisting}

\clOutputOption
{--multiple-input-outputs}
{Does the verifier support ONNX networks with multiple input or output nodes? See Section~\ref{sec:multiple-inputs-outputs} for details.}
{A boolean (\texttt{true} or \texttt{false})}
\begin{lstlisting}[style=bash]
%*\exampleVerifier* supports --multiple-inputs-outputs
true
\end{lstlisting}

\subsection{Query capabilities}

\clOutputOption
{--hidden-nodes}
{Does the verifier support queries which refer to hidden nodes in the network? See Section~\ref{sec:hidden-nodes} for details.}
{A boolean (\texttt{true} or \texttt{false})}
\begin{lstlisting}[style=bash]
%*\exampleVerifier* supports --hidden-nodes
true
\end{lstlisting}

\clOutputOption
{--multiple-networks}
{Does the verifier support queries with multiple networks? See Section~\ref{sec:multiple-networks} for details.}
{A boolean (\texttt{true} or \texttt{false})}
\begin{lstlisting}[style=bash]
%*\exampleVerifier* supports --multiple-networks
false
\end{lstlisting}

\clOutputOption
{--multiple-node-comparisons}
{Does the verifier support comparisons between variables representing different nodes in the same network? See Section~\ref{sec:multi-node-comparisons} for details.}
{A boolean (\texttt{true} or \texttt{false})}
\begin{lstlisting}[style=bash]
%*\exampleVerifier* supports --multiple-node-comparisons
true
\end{lstlisting}

\clOutputOption
{--arithmetic-complexity}
{Prints a list of supported \vnnlib{} logics, indicating the scope of theoretical support. See Section~\ref{sec:arithmetic-complexity} for details.
}
{A newline-seperated list of logics.}
\begin{lstlisting}[style=bash]
%*\exampleVerifier* supports --logics
FRA
LINEAR
R
\end{lstlisting}



