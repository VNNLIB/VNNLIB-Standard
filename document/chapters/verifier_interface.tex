\chapter{Command-line Interface}
\label{sec:solver_interface}

\newcommand{\clOutputOption}[3]{
\paragraph{\texttt{#1}}
\begin{itemize}
    \item \textbf{Description}: #2
    \item \textbf{Output}: #3
    \item \textbf{Example usage}:
\end{itemize}
}

\newcommand{\clOption}[3]{
\paragraph{\texttt{#1}}
\begin{itemize}
    \item \textbf{Description}: #2
    \item \textbf{Example usage}: \texttt{#3}
\end{itemize}
}

\lstdefinestyle{bashcommand}{
	style=bash,
    numbers=none,
    frame=none,
    backgroundcolor=\color{white}
}

\newcommand{\exampleSolver}{checkNN}

With the growing number of solvers and their increasing integration into larger toolchains, there is a clear need for a consistent and predictable way to invoke them. A standardised command-line interface (CLI) therefore enables interoperability between solvers and higher-level tools, facilitates benchmarking and automation, and reduces the burden on users adapting to multiple systems.

This chapter defines the CLI for solvers that conform to the \vnnlib{} standard. The interface supports querying solver capabilities, listing supported operations, and running verification tasks with configurable options.

\section{Invocation}

All solvers adhering to the \vnnlib{} specification should be available as an executable or script invokable by the command line, which will be referred to in this chapter as \texttt{<solver>}. The general syntax for interacting with the solver via the CLI is:
\begin{lstlisting}[style=bash]
<solver>
    [global-options] 
    <command> 
    [command-options] 
    [arguments] 
\end{lstlisting}
Throughout the following sections, \texttt{<...>} is used to indicate required values and \texttt{[...]} is used to indicate optional values. To illustrate the example usages, we will  use an imaginary solver called \texttt{\exampleSolver}.

Invoking the solver will produce output in the format described in the rest of this section. Unless stated otherwise all output should be printed on \texttt{stdout}. Detailed logs, warnings, or error messages must be printed on \texttt{stderr}.
At the moment, the \vnnlib{} standard contains two commands: \emph{verify} and \emph{capabilities}. Compliant solvers can provide additional other non-standard functionality under different commands. 

\section{Global options}

\vnnlib{} compliant solvers should implement the following global options:

\clOutputOption
{--name}
{Print the solver's full name. This can be different from the executable's name.}
{A string that may contain spaces, special characters etc.}
\begin{lstlisting}[style=bash]
%*\exampleSolver* --name
CheckNeuralNetworks!
\end{lstlisting}

\clOutputOption
{--version}
{Print the version of the solver. It is strongly recommended that solvers conform to \href{https://semver.org/}{semantic versioning}.}{A version string.}
\begin{lstlisting}[style=bash]
%*\exampleSolver* --version
1.0.1
\end{lstlisting}


\section{The \texttt{verify} command}
\label{sec:verify_command}

When invoked with the \texttt{verify} command  the solver should attempt to determine whether a satisfiable assignment of variables exist for the provided \vnnlib{} query and neural network models.

The general pattern of usage is as follows:
\begin{lstlisting}[style=bash]
<solver> verify 
  <filepath>
  [--network <name>=<filepath>]
  [--timeout <seconds>]
  [--assignments <filepath>]
\end{lstlisting}
The first argument should be the path to the \vnnlib{} query file (see Section~\ref{sec:specification_language}), and the solver should support the following additional options:

\clOption{--network}{This option maps the name of one of the networks declared in the provided \vnnlib{} query file to its implementation as an ONNX model file. When the query file contains multiple \texttt{declare-network} declarations this option should be used multiple times -- once for each network declaration not marked with an \texttt{equal-to} declaration (see Section~\ref{sec:multiple-networks}).}{--network classifier=/a/path/to/a/model.onnx}

\clOption{--timeout}{Maximum time to spend on processing on the query in an integer number of seconds.}{--timeout 10}

\clOption{--serialise-assignments}
{Instructs the solver to output satisfying assignments in the seralised format described in Section~\ref{sec:seralised-assignment-format}. This argument only needs to be supported if the solver reports that it supports serialising assignments as described in Section~\ref{sec:other-capabilities}.}
{--serialise-assignments /path/to/output}

\noindent Compliant solvers may also support additional non-standard arguments to the \texttt{verify} command to affect the internal behaviour of the verification algorithm. However, such additional non-standard arguments \textit{must} be optional.

\subsection{Output of the \texttt{verify} command}

\noindent The initial output of the command should be reported on \texttt{stdout} and should be a single line consisting of one of the following options: 
\begin{itemize}
\item \texttt{timed-out} - The allocated time elapsed before the verification procedure terminated.
\item \texttt{unknown} - The solver terminated but was unable to definitively prove whether or not the query was unsatisfiable.
\item \texttt{unsat} - The solver terminated and proved that the query was unsatisfiable.
\item \texttt{sat} - The solver terminated and proved that the query was satisfiable.
\end{itemize}
If the query is satisfiable, there are two ways that the solver can output the satisfying assignment found:
\begin{enumerate}
\item \textbf{Command-line format}: If the \texttt{--serialise-assignments} option was not passed or the solver reports not supporting it, the solver should print the assignments on \texttt{stdout}. Outputting the assignment to the command-line is therefore the default behaviour and must be supported by all solvers.
\item \textbf{Serialised format}: If the \texttt{--serialise-assignments} option was passed and the solver reports supporting it, the solver should serialise the assignments in the folder specified by the \texttt{--serialise-assignments} option.
\end{enumerate}
As a motivating example, consider a \vnnlib{} query that started with the following network declarations:
\begin{lstlisting}[style=bash]
(declare-network f
    (declare-input  A float32 [2,2])
    (declare-input  B int32   [1])
    (declare-hidden H float32 [1,2] "hidden")
    (declare-output Y float32 [1])
)
(declare-network g
    (declare-input  C float32 [2,2])
    (declare-output Z float32 [1])
)
\end{lstlisting}
and an assignment found by the solver as follows:
\begin{equation*}
A = \begin{pmatrix}
0.5 & 0.3 \\
0.4 & 0.2
\end{pmatrix}
\quad
B = \begin{pmatrix}
-1
\end{pmatrix}
\quad
H = \begin{pmatrix}
0.5 & 0.3
\end{pmatrix}
\quad
Y = \begin{pmatrix}
0.1
\end{pmatrix}
\end{equation*}
\begin{equation*}
C = \begin{pmatrix}
1.0 & 0.3 \\
0.4 & 0.2
\end{pmatrix}
\quad
Z = \begin{pmatrix}
0.0
\end{pmatrix}
\end{equation*}
The two different assignment formats are now described in more detail.

\subsubsection{Command-line assignment format}

By default, the assignment must be printed to \texttt{stdout} in the following format:
\begin{lstlisting}[style=bash]
<variable_1_name> <variable_1_type> <variable_1_dimensions>
<value>
<value>
...
<variable_n_name> <variable_n_type> <variable_n_dimensions>
\end{lstlisting}
The variables should be reported in the order that they are declared in the query file. Each assignment is reported on a separate line, with the elements in row-major order. 
Therefore for the example given above, the output should be:
\begin{lstlisting}[style=bash]
A float32 [2,2]
0.5
0.3
0.4
0.2
B int32 [1]
-1
H Real [1,2]
0.5
0.3
Y Real [1]
0.1
C Real [2,2]
1.0
0.3
0.4
0.2
Z Real [1]
0.0
\end{lstlisting}

\textbf{Note}: Although outputting the assignment via the command line as above is the default behaviour, both printing and parsing it may induce a significant overhead for very large tensors. 

\subsubsection{Serialised assignment format}
\label{sec:seralised-assignment-format}

In the case where efficiency is important, a solver may optionally support outputting assignments as a folder containing binary files of seralised ONNX TensorProto objects. If the user passes \texttt{--serialise-assignments <folder>} to the \texttt{verify} command, then the solver should generate a folder:
\begin{lstlisting}[style=bash]
<folder>/
  <variable_1_name>.pb
  <variable_2_name>.pb
  ...
  <variable_n_name>.pb
\end{lstlisting}
where each of the files contains a serialised TensorProto object of the correct element type and shape.

For the example given above, if \texttt{--serialise-assignments my/output} was passed then the solver should therefore generate the following files:
\begin{lstlisting}[style=bash]
my/output/
  A.pb
  B.pb
  H.pb
  Y.pb
  C.pb
  Z.pb
\end{lstlisting}

\section{The \texttt{supports} command}
\label{sec:global_capabilities}

When invoked with the \texttt{supports} command, the solver should report the types of queries and networks it is capable of verifying.
These options provide a way for higher-level tools to automatically assess the capabilities of the solver.

The general pattern of usage is as follows:
\begin{lstlisting}[style=bash]
<solver> supports <capability>
\end{lstlisting}
The solver must be able to respond to all of the following capabilities, although of course it may be able to report other capabilities as well.

\subsection{ONNX capabilities}

\clOutputOption
{--onnx-opset-versions}
{Prints a newline-separated pair of the minimum and maximum \href{https://onnxruntime.ai/docs/reference/compatibility.html\#onnx-opset-support}{ONNX opset versions} that the solver supports.}
{Two version strings}
\begin{lstlisting}[style=bash]
%*\exampleSolver* supports --onnx-opset-versions
13
19
\end{lstlisting}

\clOutputOption
{--onnx-element-types}
{Prints a newline-separated list of the element types that the solver supports. See Section~\ref{sec:element-types} for details.}
{List of ONNX types}
\begin{lstlisting}[style=bash]
%*\exampleSolver* supports --onnx-element-types
float64
float32
float16
real
\end{lstlisting}
\textbf{Note}: as discussed in Section~\ref{sec:element-types}, in order for a solver to report that it supports an ONNX element type, then there must be a strong reason to believe that its analysis is sound with respect to that element type. If unsound, or the soundness is unknown then the solver should only report that it supports the \texttt{real} type.

\clOutputOption
{--onnx-operators}
{Reports the ONNX operators (e.g., \texttt{Conv}, \texttt{Relu}, \texttt{Gemm}) that are supported by the solver. See Section~\ref{sec:models} for more details on the ONNX standard and its operators. 
}
{A newline-separated list of lines, where each line contains the name of an ONNX operator followed by a possibly empty space-separated list of ONNX element types. If the list is empty, then the solver is assumed to support the operator for all element types it reports via the \texttt{supports --onnx-element-types} command.
}
\begin{lstlisting}[style=bash]
%*\exampleSolver* supports --onnx-operators
Conv float64 float32
Relu float64 float32
MatMul
Gemm
Add float64 float32 int64 int32
Flatten
\end{lstlisting}

\subsection{\vnnlib{} query capabilities}

\clOutputOption
{--vnnlib-versions}
{Prints a newline-separated pair of the minimum and maximum versions (inclusive) of \vnnlib{} that the solver supports.}
{Two version strings}
\begin{lstlisting}[style=bash]
%*\exampleSolver* supports --vnnlib-versions
2.0
2.3
\end{lstlisting}

\clOutputOption
{--hidden-node-theories}
{Which \hiddenNodes{} theories described in Section~\ref{sec:hidden-nodes} does the solver support?}
{A newline-seperated list of theories}
\begin{lstlisting}[style=bash]
%*\exampleSolver* supports --hidden-node-theories
NH
\end{lstlisting}

\clOutputOption
{--multiple-input-output-theories}
{Which \multiIO{} theories described in Section~\ref{sec:multiple-inputs-outputs} does the solver support?}
{A newline-seperated list of theories}
\begin{lstlisting}[style=bash]
%*\exampleSolver* supports --multiple-inputs-output-theories
SNET
MENET
\end{lstlisting}

\clOutputOption
{--multiple-network-theories}
{Which \multiNetwork{} theories described in Section~\ref{sec:multiple-networks} does the solver support?}
{A newline-seperated list of theories}
\begin{lstlisting}[style=bash]
%*\exampleSolver* supports --multiple-network-theories
SIO
\end{lstlisting}

\clOutputOption
{--multiple-node-comparison-theories}
{Which \multiComparison{} theories described in Section~\ref{sec:multi-node-comparisons} does the solver support?}
{A newline-seperated list of theories}
\begin{lstlisting}[style=bash]
%*\exampleSolver* supports --multiple-node-comparison-theories
MNC
\end{lstlisting}

\clOutputOption
{--arithmetic-complexity-theories}
{Which \arithComplexity{} theories described in Section~\ref{sec:arithmetic-complexity} does the solver support?
}
{A newline-seperated list of theories.}
\begin{lstlisting}[style=bash]
%*\exampleSolver* supports --arithmetic-complexity-theories
LIN
\end{lstlisting}

\clOutputOption
{--optimised-disjunctive-reasoning}
{Does the solver uses an intelligent strategy for handling queries involving \texttt{(or ...)} statements or simply translates them to disjunctive normal form? If the latter, then higher-level tools can use this flag to decide whether to perform the conversion to DNF themselves and hence get a better indication of progress.
}
{A boolean (\texttt{true} or \texttt{false})}
\begin{lstlisting}[style=bash]
%*\exampleSolver* supports --optimised-disjunctive-reasoning
true
\end{lstlisting}

\subsection{Other capabilities}
\label{sec:other-capabilities}

\clOutputOption
{--serialise-assignments}
{Does the solver support the \texttt{--serialise-assignments} option to the \texttt{verify} command? See Section~\ref{sec:verify_command} for details.}
{A boolean (\texttt{true} or \texttt{false})}
\begin{lstlisting}[style=bash]
%*\exampleSolver* supports --serialise-assignments
true
\end{lstlisting}




