\documentclass[12pt,a4paper]{report}

\usepackage[english]{babel}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage[colorlinks = true,
            linkcolor = black,
            urlcolor  = blue,
            %citecolor = blue,
            %anchorcolor = blue
            ]{hyperref}
\usepackage{authblk}
\usepackage{subcaption}
\usepackage{geometry}
\usepackage{booktabs}
\usepackage{array}
\usepackage[font={small,it}]{caption}
\usepackage{nameref}
\usepackage{mathpartir}
\usepackage{stmaryrd}
\usepackage[nounderscore]{syntax}

\usepackage[T1]{fontenc}
\usepackage{lmodern}

%%%%%%%%%%%%
% Diagrams %
%%%%%%%%%%%%

\usepackage{tikz}
\usetikzlibrary{
    arrows.meta,      % For arrow styles
    positioning,      % For relative positioning of nodes
    shapes.geometric, % For shapes like rounded rectangles
    trees             % For drawing tree structures
}

%%%%%%%%%%%
% Colours %
%%%%%%%%%%%

\usepackage{xcolor}
\definecolor{lightgreen}{rgb}{0.8,1.0,0.8}
\definecolor{red}{rgb}{0.8,0,0}
\definecolor{green}{rgb}{0,0.8,0}
\definecolor{blue}{rgb}{0,0,1}
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}
\definecolor{keywordblue}{rgb}{0.13,0.13,1}
\definecolor{stringred}{rgb}{0.8,0,0}

%%%%%%%%%%%%%%%
% TODO macros %
%%%%%%%%%%%%%%%
\setlength {\marginparwidth}{2cm}
\usepackage{todonotes}
\newcommand{\mytodo}[1]{\todo[inline,color=lightgreen]{TODO:#1}}
\newcommand{\mnote}[2][]{\todo[inline,color=red!10,#1]{Matthew: #2}}
\newcommand{\myremark}[1]{\todo[inline, color=lightgreen]{\textbf{Remark:} #1}}

%%%%%%%%%%%%%%%%
% Common terms %
%%%%%%%%%%%%%%%%

\newcommand{\vnnlib}{VNN-LIB}
\newcommand{\ie}{\textit{i.e.}}

\newcommand{\nilList}{[\:]}
\newcommand{\consList}[2]{#1 :: #2}

%%%%%%%%%%%%%
% Semantics %
%%%%%%%%%%%%%

\newcommand{\mgrammar}[1]{\text{\small \textit{#1}}}
\newcommand{\set}{\text{Set}}
\newcommand{\field}[2]{#1.\text{#2}}

\newcommand{\sem}[1]{\llbracket #1 \rrbracket}
\newcommand{\semenv}[1]{\llbracket #1 \rrbracket^{\Delta_N,\Delta_A}}

\newcommand{\real}{\ensuremath{\mathbb{R}}}

%%%%%%%%%%%%%%%%%%
% Network theory %
%%%%%%%%%%%%%%%%%%

\newcommand{\networkTheory}{Network Theory}
\newcommand{\networkTheoryVar}{\Psi}
\newcommand{\missing}{\ensuremath{\square}}

\newcommand{\elementVar}{d}
\newcommand{\modelVar}{m}
\newcommand{\tensorVar}{t}

\newcommand{\shapeVar}{s}
\newcommand{\elementTypeVar}{\tau}
\newcommand{\tensorTypeVar}{\delta}
\newcommand{\modelTypeVar}{\gamma}

\newcommand{\inputNodesFn}{inputs}
\newcommand{\outputNodesFn}{\text{networkOutputs}}

\newcommand{\semApp}[2]{\sem{#2}_\text{#1}}
\newcommand{\semElementType}[1]{\semApp{elementType}{#1}}
\newcommand{\semTensorType}[1]{\semApp{tensorType}{#1}}
\newcommand{\semTensor}[1]{\semApp{tensor}{#1}}
\newcommand{\semModelType}[1]{\semApp{modelType}{#1}}
\newcommand{\semModel}[1]{\semApp{model}{#1}}

\newcommand{\semElementTypeAbs}{\semApp{elementType}{\cdot}}
\newcommand{\semTensorAbs}{\semApp{tensor}{\cdot}}
\newcommand{\semModelAbs}{\semApp{model}{\cdot}}

\newcommand{\networkTheoryVarParam}{^\networkTheoryVar}
\newcommand{\semElementTypeTheory}[1]{\semElementType{#1}\networkTheoryVarParam}
\newcommand{\semTensorTypeTheory}[1]{\semTensorType{#1}\networkTheoryVarParam}
\newcommand{\semTensorTheory}[1]{\semTensor{#1}\networkTheoryVarParam}
\newcommand{\semModelTypeTheory}[1]{\semModelType{#1}\networkTheoryVarParam}
\newcommand{\semModelTheory}[1]{\semModel{#1}\networkTheoryVarParam}

%%%%%%%%%%
% VNNLIB %
%%%%%%%%%%

\newcommand{\queryVar}{q}
\newcommand{\versionVar}{v}
\newcommand{\nameVar}{v}
\newcommand{\equivVar}{e}
\newcommand{\onnxNameVar}{u}
\newcommand{\nodeVar}{z}

\newcommand{\networkDeclVar}{n}
\newcommand{\networkDeclSet}{N}

\newcommand{\inputDeclVar}{i}
\newcommand{\inputDeclSet}{I}

\newcommand{\hiddenDeclVar}{h}
\newcommand{\hiddenDeclSet}{H}

\newcommand{\outputDeclVar}{o}
\newcommand{\outputDeclSet}{O}

\newcommand{\assertionVar}{a}
\newcommand{\assertionSet}{A}

\newcommand{\namedNetworkExpansion}[1]
{
\texttt{declare-network} ~
#1 ~
\equivVar ~
\inputDeclSet ~
\hiddenDeclSet ~
\outputDeclSet
}

\newcommand{\networkExpansion}{\namedNetworkExpansion{\nameVar}}

\newcommand{\queryExpansion}
{
\versionVar ~
\networkDeclSet ~
\assertionSet
}

\newcommand{\inputExpansion}
{
\texttt{declare-input} ~
\nameVar ~
\elementTypeVar ~
\shapeVar
}

\newcommand{\hiddenExpansion}
{
\texttt{declare-hidden} ~
\nameVar ~
\elementTypeVar ~
\shapeVar ~
\onnxNameVar
}

\newcommand{\outputExpansion}
{
\texttt{declare-output} ~
\nameVar ~
\elementTypeVar ~
\shapeVar
}
\newcommand{\assertCtx}{\Gamma}
\newcommand{\networkCtx}{\assertCtx^N}
\newcommand{\variableCtx}{\assertCtx^V}

\newcommand{\assertEnv}{\Delta}
\newcommand{\semQuery}[1]{\semApp{query}{#1}}
\newcommand{\semNetwork}[1]{\semApp{network}{#1}}
\newcommand{\semArith}[1]{\semApp{arith}{#1}^\assertEnv}
\newcommand{\semBool}[1]{\semApp{bool}{#1}^\assertEnv}
\newcommand{\semAssert}[1]{\semApp{assert}{#1}^\assertEnv}

\newcommand{\networkDeclType}{\text{modelType}}
\newcommand{\networkInputsType}{\text{inputTypes}}


\newcommand{\networkImplementation}{\modelVar}
\newcommand{\networkImplementationSet}{M}

\newcommand{\networkInputTensor}{t}
\newcommand{\networkInputTensors}{[\networkInputTensor_1 \ldots \networkInputTensor_n]}

\newcommand{\networkInput}{x}
\newcommand{\networkInputSet}{X}
\newcommand{\networkInputSets}{\mathcal{X}}

\newcommand{\newImplementationCtx}{\Gamma}

%%%%%%%%%%%%
% Theories %
%%%%%%%%%%%%

% Theory sets
\newcommand{\theoryset}[1]{\textbf{#1}}
\newcommand{\hiddenNodes}{\theoryset{Hidden Nodes}}
\newcommand{\multiIO}{\theoryset{Multiple Inputs/Outputs}}
\newcommand{\multiNetwork}{\theoryset{Multiple Networks}}
\newcommand{\multiComparison}{\theoryset{Multiple Node Comparisons}}
\newcommand{\arithComplexity}{\theoryset{Arithmetic Complexity}}

% Theories
\newcommand{\theory}[1]{\texttt{#1}}
\newcommand{\nh}{\theory{NH}}
\newcommand{\h}{\theory{H}}
\newcommand{\snet}{\theory{SNET}}
\newcommand{\mnet}{\theory{MNET}}
\newcommand{\menet}{\theory{MENET}}
\newcommand{\minet}{\theory{MINET}}
\newcommand{\sio}{\theory{SIO}}
\newcommand{\mio}{\theory{MIO}}
\newcommand{\snc}{\theory{SNC}}
\newcommand{\mnc}{\theory{MNC}}
\newcommand{\bnd}{\theory{BND}}
\newcommand{\cout}{\theory{OUTC}}
\newcommand{\lin}{\theory{LIN}}
\newcommand{\poly}{\theory{POLY}}

%%%%%%%%%%
% Logics %
%%%%%%%%%%

\newcommand{\logicVar}{\mathcal{L}}
\newcommand{\logicSet}{\mathbb{L}}
\newcommand{\logic}[1]{\texttt{#1}}

%%%%%%%%%%%%%%%%%%%%%
% Code highlighting %
%%%%%%%%%%%%%%%%%%%%%

\usepackage{listings}
\renewcommand{\lstlistingname}{Example}

% Listings style for BNFC commands
\lstdefinestyle{lbnf}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{keywordblue}\bfseries,
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{stringred},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=1,
    frame=lines,
    xleftmargin=2em,
    framexleftmargin=1.5em,
    escapeinside={\%*}{*}
}

% Listings style for Bash/CLI commands
\lstdefinestyle{bash}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{keywordblue}\bfseries,
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{stringred},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2,
    frame=lines,
    xleftmargin=2em,
    framexleftmargin=1.5em,
    escapeinside={\%*}{*} 
}

% Stops code splitting over multiple pages
\lstnewenvironment{code}[1][]%
{
    \noindent
    \minipage{\linewidth} 
    \vspace{0.5\baselineskip}
    \lstset{basicstyle=\ttfamily\footnotesize,frame=single,#1}
}
{
    \endminipage
}

\newcommand{\inlinevnn}[1]{\texttt{#1}}

%%%%%%%%%%%%
% Metadata %
%%%%%%%%%%%%

\title{
	The \vnnlib{} Standard \\ 
	Version 2.0.0 (draft)
}

\author[1]{Stefano Demarchi}
\author[2]{Dario Guidotti}
\author[2]{Luca Pulina}
\author[1]{Armando Tacchella}

\author[3]{Ann Roy}
\author[3]{Allen Antony}
\author[3]{Matthew Daggitt}

\affil[1]{University of Genoa, Italy}
\affil[2]{University of Sassari, Italy}
\affil[3]{University of Western Australia, Australia}
  
%%%%%%%%%%%%
% Document %
%%%%%%%%%%%%

\begin{document}

\maketitle

\begin{abstract}
This document presents \vnnlib{} -- an open-source standard for automated solvers of satisfiability problems over neural networks. 
The goal of the standard is to foster greater robustness and interoperability in the neural network verification landscape.
To this end, the standard defines: i) a formal syntax for defining satisfiabilty queries over neural networks, ii) a formal semantics for that syntax and iii) and a command-line interface for solvers.
\end{abstract}

\tableofcontents

\input{chapters/introduction.tex}
\input{chapters/models.tex}
\input{chapters/query_language.tex}
\input{chapters/logics.tex}
\input{chapters/verifier_interface.tex}

\appendix

\bibliography{bibliography}
\bibliographystyle{plain}

\end{document}
