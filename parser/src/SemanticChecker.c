/* Adapted from Skeleton.c generated by the BNFC Converter  */
/*** Semantic Error Checking using Visitor Traversal. ***/

#include "SemanticChecker.h" // Include the header above

// --- Semantic Context Initialization and Cleanup ---

// Initialize the semantic context
void initSemanticContext(SemanticContext *ctx) {
    if (!ctx) return;
    ctx->symbolTableHead = NULL;
    ctx->errorCount = 0;
}


// Helper to free symbol info (does not free nodes from original AST)
void freeSymbolInfo(SymbolInfo *info) {
    if (!info) return;
    free(info->name); 
    free(info->shape); 
    free(info);        
}


// Free all symbols in the context
void destroySemanticContext(SemanticContext *ctx) {
    if (!ctx) return;
    SymbolInfo *current = ctx->symbolTableHead;
    SymbolInfo *next;
    while (current != NULL) {
        next = current->next;
        freeSymbolInfo(current);
        current = next;
    }
    ctx->symbolTableHead = NULL;
    ctx->errorCount = 0;
}


// Basic error reporting
void reportError(SemanticContext *ctx, const char *format, ...) {
    if (ctx) {
        ctx->errorCount++;
        fprintf(stderr, "Semantic Error: ");
        va_list args;
        va_start(args, format);
        vfprintf(stderr, format, args);
        va_end(args);
        fprintf(stderr, "\n");
    } else {
        fprintf(stderr, "Semantic Error: Context unavailable. Message: %s\n", format);
    }
}


// Add symbol to table (simple linked list, checks for duplicates)
// Returns the added symbol or NULL if an error occurred
SymbolInfo* addSymbol(SemanticContext *ctx, VariableName name, ElementType type, ListInt listInt, SymbolKind kind) {
    // Check for duplicates
    int is_symbol = ctx->symbolTableHead != NULL;

    SymbolInfo *existing = findSymbol(ctx, name);
    if (existing) {
        reportError(ctx, "Variable '%s' already declared.", name);
        // TODO: report where it was previously declared if line numbers are available
        return NULL;
    }

    // Create new symbol info
    SymbolInfo *newSymbol = (SymbolInfo*)malloc(sizeof(SymbolInfo));

    if (!newSymbol) {
        perror("Failed to allocate memory for symbol shape");
        exit(EXIT_FAILURE);
    } 

    int *symbolShape = malloc(sizeof(int) * MAX_DIMENSIONS);
    int numDimensions = 0; 

    if (!symbolShape) {
        perror("Failed to allocate memory for symbol shape");
        free(newSymbol);
        exit(EXIT_FAILURE);
    }

    if (listInt && checkListInt(listInt, ctx, symbolShape, &numDimensions) != 0) {
        free(symbolShape);
        free(newSymbol);
    }

	// Store pointers to original AST nodes
	newSymbol->name = strdup(name);

    if (!newSymbol->name) {
        perror("Failed to duplicate symbol name");
        free(symbolShape);
        free(newSymbol);
    }

    newSymbol->type = type;              
    newSymbol->kind = kind;
    newSymbol->shape = symbolShape;
    newSymbol->numDimensions = numDimensions;

	// Add to front of linked list
    newSymbol->next = ctx->symbolTableHead;
    ctx->symbolTableHead = newSymbol;
    return newSymbol;
}


// Find symbol by name
SymbolInfo* findSymbol(SemanticContext *ctx, VariableName name) {
    if (!ctx || !name || !ctx->symbolTableHead) return NULL;
    SymbolInfo *current = ctx->symbolTableHead;
    while (current != NULL) {
        if (strcmp(current->name, name) == 0) {
            return current;
        }
        current = current->next;
    }
    return NULL; // Not found
}


// Main entry point
int checkSemantics(Query p) {
    SemanticContext ctx;
    initSemanticContext(&ctx);

    checkQuery(p, &ctx); // Start traversal

    int finalErrorCount = ctx.errorCount;
    destroySemanticContext(&ctx); // Clean up allocated symbols

    if (finalErrorCount > 0) {
        fprintf(stderr, "Found %d semantic error(s).\n", finalErrorCount);
        return 1; // Indicate failure
    } else {
        return 0; // Indicate success
    }
}


// ----------------- Recursive Traversal Functions -----------------

// Check the ListInt production and add each discovered Int to the provided shape array
int checkListInt(ListInt p, SemanticContext *ctx, int *shape, int *shapeSize)
{
    if (!p) return 0;  // ListInt is optional
    int err = 0; 
    while(p  != 0 && err == 0)
    {
        err |= checkInt(p->int_, ctx);

        if (err) {
            reportError(ctx, "Invalid integer in ListInt at index %s.", *shapeSize);
            return 1;
        } 
        
        if (*shapeSize >= MAX_DIMENSIONS) {
            reportError(ctx, "Exceeded maximum allowed dimensions (%d) for Tensor", MAX_DIMENSIONS);
            return 1;
        }

        shape[*shapeSize] = strtol(p->int_, NULL, 10); // Convert string to int
        p = p->listint_;
        (*shapeSize)++;
    }
    return err; // Propagate error if any element failed
}


int checkArithExpr(ArithExpr p, SemanticContext *ctx)
{
    if (!p) return 1;
    int err = 0;
    switch(p->kind)
    {
        case is_VarExpr:
            err |= checkTensorElement(p->u.varexpr_.tensorelement_, ctx);
            break;
        case is_DoubleExpr:
            err |= checkSDouble(p->u.doubleexpr_.sdouble_, ctx);
            break;
        case is_SIntExpr:
            err |= checkSInt(p->u.sintexpr_.sint_, ctx);
            break;
        case is_IntExpr:
            err |= checkInt(p->u.intexpr_.int_, ctx);
            break;
        case is_Negate:
            err |= checkArithExpr(p->u.negate_.arithexpr_, ctx);
            break;
        case is_Plus:
            // TODO Check for at least two elements in the list
            err |= checkListArithExpr(p->u.plus_.listarithexpr_, ctx);
            break;
        case is_Minus:
			// TODO: Check for at least two elements in the list
            err |= checkArithExpr(p->u.minus_.arithexpr_, ctx);
            err |= checkListArithExpr(p->u.minus_.listarithexpr_, ctx);
            break;
        case is_Multiply:
			// TODO: Check: Check for at least two elements in the list
            err |= checkListArithExpr(p->u.multiply_.listarithexpr_, ctx);
            break;

        default:
            reportError(ctx, "Bad kind field in ArithExpr node.");
            return 1; // Error
    }
    return err; // Propagate error if any check failed
}


int checkListArithExpr(ListArithExpr p, SemanticContext *ctx)
{
    if (!p) return 1;
    int err = 0;
    while(p  != 0 && err == 0)
    {
        err |= checkArithExpr(p->arithexpr_, ctx);
        p = p->listarithexpr_;
    }
    return err;
}


int checkBoolExpr(BoolExpr p, SemanticContext *ctx)
{
    if (!p) return 1;
    int err = 0;
    switch(p->kind)
    {
        // TODO: Check number of inputs is >= 2 and return warning if not

        case is_GreaterThan:
            err |= checkArithExpr(p->u.greaterthan_.arithexpr_1, ctx);
            err |= checkArithExpr(p->u.greaterthan_.arithexpr_2, ctx);
            break;
        case is_LessThan:
            err |= checkArithExpr(p->u.lessthan_.arithexpr_1, ctx);
            err |= checkArithExpr(p->u.lessthan_.arithexpr_2, ctx);
            break;
        case is_GreaterEqual:
            err |= checkArithExpr(p->u.greaterequal_.arithexpr_1, ctx);
            err |= checkArithExpr(p->u.greaterequal_.arithexpr_2, ctx);
            break;
        case is_LessEqual:
            err |= checkArithExpr(p->u.lessequal_.arithexpr_1, ctx);
            err |= checkArithExpr(p->u.lessequal_.arithexpr_2, ctx);
            break;
        case is_NotEqual:
            err |= checkArithExpr(p->u.notequal_.arithexpr_1, ctx);
            err |= checkArithExpr(p->u.notequal_.arithexpr_2, ctx);
            break;
        case is_Equal:
            err |= checkArithExpr(p->u.equal_.arithexpr_1, ctx);
            err |= checkArithExpr(p->u.equal_.arithexpr_2, ctx);
            break;

        case is_And:
            err |= checkListBoolExpr(p->u.and_.listboolexpr_, ctx);
            break;
        case is_Or:
            err |= checkListBoolExpr(p->u.or_.listboolexpr_, ctx);
            break;

        default:
			reportError(ctx, "Bad kind field in BoolExpr node.");
			return 1;
    }
	return err;
}


int checkListBoolExpr(ListBoolExpr p, SemanticContext *ctx)
{
    if (!p) return 1;
    int err = 0;
    while(p  != 0 && err == 0)
    {
        err |= checkBoolExpr(p->boolexpr_, ctx);
        p = p->listboolexpr_;
    }
    return err;
}


int checkProperty(Property p, SemanticContext *ctx)
{
    if (!p) return 1;
    int err = 0;
    switch(p->kind)
    {
        case is_Prop:
            err |= checkBoolExpr(p->u.prop_.boolexpr_, ctx);
            break;

        default:
			reportError(ctx, "Bad kind field in Property node.");
			return 1;
    }
    return err;
}


int checkListProperty(ListProperty p, SemanticContext *ctx)
{
    if (!p) return 1;
    int err = 0;
    while(p  != 0 && err == 0)
    {
        err |= checkProperty(p->property_, ctx);
        p = p->listproperty_;
    }
    return err;
}


int checkElementType(ElementType p, SemanticContext *ctx)
{
    if (!p) return 1;
	switch(p->kind)
	{
        case is_GenericElementType: break;
        case is_ElementTypeF16: break;
        // ... all other cases ... (Shortened for brevity)
        case is_ElementTypeString: break;

        default:
            reportError(ctx, "Bad kind field in ElementType node.");
            return 1; 
	}
	return 0; 
}


int checkInputDefinition(InputDefinition p, SemanticContext *ctx)
{
    if (!p) return 1;
    int err = 0;
    switch(p->kind)
    {
        case is_InputDef:
            err |= checkVariableName(p->u.inputdef_.variablename_, ctx);
            err |= checkElementType(p->u.inputdef_.elementtype_, ctx);
            if (err) return err; // Don't proceed if children have errors

            // Check for duplicate symbols
            if (!addSymbol(ctx, p->u.inputdef_.variablename_, p->u.inputdef_.elementtype_, p->u.inputdef_.listint_, SYM_INPUT)) {
                err = 1; 
            }
            break;

        default:
            reportError(ctx, "Bad kind field in InputDefinition node.");
            return 1; 
    }
    return err;
}


int checkIntermediateDefinition(IntermediateDefinition p, SemanticContext *ctx)
{
    if (!p) return 1;
	int err = 0;
	switch(p->kind)
	{
        case is_IntermediateDef:
            err |= checkVariableName(p->u.intermediatedef_.variablename_, ctx);
            err |= checkElementType(p->u.intermediatedef_.elementtype_, ctx);
            err |= checkString(p->u.intermediatedef_.string_, ctx);
            if (err) return err;

            // Check for duplicate symbols
            if (!addSymbol(ctx, p->u.intermediatedef_.variablename_, p->u.intermediatedef_.elementtype_, p->u.intermediatedef_.listint_, SYM_INTERMEDIATE)) {
                err = 1;
            }
            break;

        default:
			reportError(ctx, "Bad kind field in IntermediateDefinition node.");
			return 1;
	}
	return err;
}


int checkOutputDefinition(OutputDefinition p, SemanticContext *ctx)
{
    if (!p) return 1;
	int err = 0;
	switch(p->kind)
	{
        case is_OutputDef:
            err |= checkVariableName(p->u.outputdef_.variablename_, ctx);
            err |= checkElementType(p->u.outputdef_.elementtype_, ctx);
            if (err) return err;

            // Check for duplicate symbols
            if (!addSymbol(ctx, p->u.outputdef_.variablename_, p->u.outputdef_.elementtype_, p->u.outputdef_.listint_, SYM_OUTPUT)) {
                err = 1;
            }
            break;

        default:
            reportError(ctx, "Bad kind field in OutputDefinition node.");
            return 1; // Error
	}
	return err;
}


int checkListInputDefinition(ListInputDefinition p, SemanticContext *ctx)
{	
    if (!p) return 1;
    int err = 0;
    while(p  != 0 && err == 0)
    {
        err |= checkInputDefinition(p->inputdefinition_, ctx);
        p = p->listinputdefinition_;
    }
    return err;
}


int checkListIntermediateDefinition(ListIntermediateDefinition p, SemanticContext *ctx)
{
	if (!p) return 0; // ListIntermediateDefinition is optional
    int err = 0;
    while(p  != 0 && err == 0)
    {
        err |= checkIntermediateDefinition(p->intermediatedefinition_, ctx);
        p = p->listintermediatedefinition_;
    }
    return err;
}


int checkListOutputDefinition(ListOutputDefinition p, SemanticContext *ctx)
{
    if (!p) return 1;
    int err = 0;
    while(p  != 0 && err == 0)
    {
        err |= checkOutputDefinition(p->outputdefinition_, ctx);
        p = p->listoutputdefinition_;
    }
    return err;
}


int checkNetworkDefinition(NetworkDefinition p, SemanticContext *ctx)
{
    if (!p) return 1;
	int err = 0;
	switch(p->kind)
	{
        case is_NetworkDef:
            // TODO: Store context of network: ctx->currentNetwork = p->u.networkdef_.variablename_;

            err |= checkVariableName(p->u.networkdef_.variablename_, ctx);

            // Process definitions - this populates the symbol table
            err |= checkListInputDefinition(p->u.networkdef_.listinputdefinition_, ctx);
            err |= checkListIntermediateDefinition(p->u.networkdef_.listintermediatedefinition_, ctx);
            err |= checkListOutputDefinition(p->u.networkdef_.listoutputdefinition_, ctx);
            break;

        default:
            reportError(ctx, "Bad kind field in NetworkDefinition node.");
            return 1; 
	}
	return err;
}


int checkListNetworkDefinition(ListNetworkDefinition p, SemanticContext *ctx)
{
    if (!p) return 1;
    int err = 0;
    while(p  != 0 && err == 0)
    {
        err |= checkNetworkDefinition(p->networkdefinition_, ctx);
        p = p->listnetworkdefinition_;
    }
    return err;
}


int checkQuery(Query p, SemanticContext *ctx)
{
    if (!p) return 1;
    int err = 0;
    switch(p->kind)
    {
    case is_VNNLibQuery:
        // 1. Process network definitions (populates symbol table)
        err |= checkListNetworkDefinition(p->u.vnnlibquery_.listnetworkdefinition_, ctx);

        // If network definitions stop
		if (err) return err;

        // 2. Process properties (uses symbol table for checks)
        err |= checkListProperty(p->u.vnnlibquery_.listproperty_, ctx);
        break;

    default:
        reportError(ctx, "Bad kind field in Query node.");
        return 1; // Error
    }
    return err;
}


// --- Base Type Checkers ---
// Return err if the base type is not NULL

int checkSDouble(SDouble p, SemanticContext *ctx) { return 0; }
int checkSInt(SInt p, SemanticContext *ctx) { return 0; }
int checkInt(Int p, SemanticContext *ctx) { return 0; }
int checkVariableName(VariableName p, SemanticContext *ctx) { return 0; }
int checkIdent(Ident i, SemanticContext *ctx) { return 0; }      
int checkInteger(Integer i, SemanticContext *ctx) { return 0; }
int checkDouble(Double d, SemanticContext *ctx) { return 0; }
int checkChar(Char c, SemanticContext *ctx) { return 0; }
int checkString(String s, SemanticContext *ctx) { return 0; }


// Checks usage of tensor elements
int checkTensorElement(TensorElement p, SemanticContext *ctx) {
    if (!p) return 1;
    int err = 0;
    int* indices = NULL;

    // Extract the tensor name and dimension from the string
    char *tensorName = strdup(p);
	char *tensorDim = strchr(tensorName, '_');
    *tensorDim = '\0'; // Terminate the variable name
    tensorDim = tensorDim ? tensorDim + 1 : NULL; 

    // Check that the tensor indices are provided
    if (!tensorDim) {
        reportError(ctx, "Invalid tensor element '%s'. Expected format: <tensor>_<index>", p);
        err = 1;
        goto cleanup;
    }

    SymbolInfo *symbol = findSymbol(ctx, tensorName); 

    // Check that variable is declared
    if (!symbol) {
        reportError(ctx, "Variable '%s' used but not declared.", p);
        err = 1;
        goto cleanup;
    }

    // Check that index is 0 for scalar variables
    else if (symbol->numDimensions == 0) {
        int index = strtol(tensorDim, NULL, 10);
        if (index != 0) {
            reportError(ctx, "Variable '%s' is not a tensor, expected dummy index 0. \
                For example %s_0", p, tensorName);
            err = 1;
            goto cleanup;
        }
    }

    // Check that indices are valid for tensor variables
    else {
        int *indices = malloc(sizeof(int) * symbol->numDimensions);
        if (!indices) {
            perror("Failed to allocate memory for indices array");
            err = 1;
            goto cleanup;
        }

        int idx = 0;
        char *token;

        // Check that the correct number of indices are provided
        token = strtok(tensorDim, ",");

        while (idx < symbol->numDimensions) {
            if (token == NULL) {
                reportError(ctx, "Not enough indices provided for Tensor Element '%s'. \
                     Expected %d indices but encountered %d.", p, symbol->numDimensions, idx + 1);
                err = 1;
                goto cleanup;
            }

            indices[idx] = strtol(token, NULL, 10);
            idx++;
            token = strtok(NULL, ",");
        }

        if (token != NULL) {
            reportError(ctx, "Too many indices provided for Tensor Element '%s'. \
                 Expected %d indices but encountered %d.", p, symbol->numDimensions, idx + 1);
            err = 1;
            goto cleanup;
        }

        // Check that indices are within bounds
        for (int i = 0; i < symbol->numDimensions; i++) {
            if (indices[i] < 0 || indices[i] >= symbol->shape[i]) {
                reportError(ctx, "Index %d out of bounds for Tensor Element '%s'. \
                    Expected index in range [0, %d)", indices[i], p, symbol->shape[i]);
                err = 1;
                goto cleanup;
            }
        }
    }

    cleanup:
        free(tensorName);     
        free(indices);        
        return err;          
}