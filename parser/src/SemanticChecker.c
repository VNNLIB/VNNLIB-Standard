/* Adapted from Skeleton.c generated by the BNFC Converter  */
/*** Semantic Error Checking using Visitor Traversal. ***/

#include "SemanticChecker.h"


// --- Error Reporting ---

// Helper to intitialise the error list
int initErrorList(SemanticContext *ctx) {
    ctx->errors = malloc(ERR_INITIAL_CAPACITY * sizeof(VNNLibError));
    if (!ctx->errors) {
        perror("Failed to allocate memory for error list");
        return 1;
    }
    ctx->errorCount = 0;
    ctx->errorCapacity = ERR_INITIAL_CAPACITY;
    return 0;
}


// Add an error to the list
void addError(SemanticContext *ctx, VNNLibError error) {
    int errorCount = ctx->errorCount;
    int errorCapacity = ctx->errorCapacity;

    if (errorCount >= errorCapacity) {
        size_t new_capacity = errorCapacity * 2;
        VNNLibError* new_errors = realloc(ctx->errors, new_capacity * sizeof(VNNLibError));
        if (!new_errors) {
            perror("Failed to reallocate memory for error list");
            return;
        }
        ctx->errors = new_errors;
        ctx->errorCapacity = new_capacity;
    }

    // Create a deep copy of the error
    VNNLibError copy = {
        .message = strdup_safe(error.message),
        .offendingSymbol = strdup_safe(error.offendingSymbol),
        .hint = strdup_safe(error.hint),
        .errorCode = error.errorCode
    };

    ctx->errors[ctx->errorCount] = copy;
    ctx->errorCount++;
}


// Helper to free the error list
void freeErrorList(SemanticContext *ctx) {
    for (int i = 0; i < ctx->errorCount; i++) {
        free_safe(ctx->errors[i].message);
        free_safe(ctx->errors[i].offendingSymbol);
        free_safe(ctx->errors[i].hint);
    }
    free_safe(ctx->errors);
    ctx->errors = NULL;
    ctx->errorCount = 0;
    ctx->errorCapacity = 0;
}


// Basic error reporting to stderr
void reportError(SemanticContext *ctx, const char *format, ...) {
    if (ctx) {
        fprintf(stderr, "Semantic Error: ");
        va_list args;
        va_start(args, format);
        vfprintf(stderr, format, args);
        va_end(args);
        fprintf(stderr, "\n");
    } else {
        fprintf(stderr, "Semantic Error: Context unavailable. Message: %s\n", format);
    }
}


// Helper to convert error codes to strings
const char* errorCodeToString(ErrorCode code) {
    switch (code) {
        case MultipleDeclaration: return "MultipleDeclaration";
        case TypeMismatch: return "TypeMismatch";
        case UndeclaredVariable: return "UndeclaredVariable";
        case IndexOutOfBounds: return "IndexOutOfBounds";
        case TooManyIndices: return "TooManyIndices";
        case NotEnoughIndices: return "NotEnoughIndices";
        default: return "UnknownErrorCode";
    }
}


// Helper to return errors as a string in a human-readable format
char *reportErrors(SemanticContext *ctx) {
    size_t size = 1024;
    size_t used = 0;
    char *buffer = malloc(size);
    if (!buffer) {
        perror("Failed to allocate memory for error report");
        return NULL;
    }
    buffer[0] = '\0';

    if (ctx && ctx->errorCount > 0) {
        for (int i = 0; i < ctx->errorCount; i++) {
            VNNLibError e = ctx->errors[i];
            buffer = append_str(buffer, &size, &used, 
                "[%s] %s (symbol: %s)\nHint: %s\n", 
                errorCodeToString(e.errorCode),
                e.message, 
                e.offendingSymbol, 
                e.hint);

            buffer = append_str(buffer, &size, &used, "\n");

            if (!buffer) {
                fprintf(stderr, "Error: Buffer overflow while reporting errors.\n");
                return NULL;
            }
        }
    }

    return buffer;
}


// Helper to return errors as a JSON string
char *reportErrorsJSON(SemanticContext *ctx) {
    size_t size = 1024;
    size_t used = 0;
    char *buffer = malloc(size);
    if (!buffer) {
        perror("Failed to allocate memory for JSON error report");
        return NULL;
    }
    buffer[0] = '\0';
    buffer = append_str(buffer, &size, &used, "{\n  \"errors\": [\n");


    if (ctx && ctx->errorCount > 0) {
        for (int i = 0; i < ctx->errorCount; i++) {
            VNNLibError e = ctx->errors[i];
            buffer = append_str(buffer, &size, &used,
                "    {\n"
                "      \"message\": \"%s\",\n"
                "      \"offendingSymbol\": \"%s\",\n"
                "      \"hint\": \"%s\",\n"
                "      \"errorCode\": \"%s\"\n"
                "    }",
                e.message,
                e.offendingSymbol,
                e.hint,
                errorCodeToString(e.errorCode));

            if (i < ctx->errorCount - 1) {
                buffer = append_str(buffer, &size, &used, ",");
            }
            buffer = append_str(buffer, &size, &used, "\n");

            if (buffer == NULL) {
                fprintf(stderr, "Error: Buffer overflow while reporting errors.\n");
                free(buffer);
                return NULL;
            }
        }
    }

    buffer = append_str(buffer, &size, &used, "  ]\n}\n");
    return buffer;
}


// --- Semantic Context Initialization and Cleanup ---

// Initialize the semantic context
int initSemanticContext(SemanticContext *ctx) {
    if (!ctx) return 1;
    ctx->symbolTableHead = NULL;
    ctx->errorCount = 0;
    return initErrorList(ctx);
}


// Helper to free symbol info (does not free nodes from original AST)
void freeSymbolInfo(SymbolInfo *info) {
    if (!info) return;
    free_safe(info->name); 
    free_safe(info->shape); 
    free_safe(info);        
}


// Free all symbols in the context
void destroySemanticContext(SemanticContext *ctx) {
    if (!ctx) return;
    SymbolInfo *current = ctx->symbolTableHead;
    SymbolInfo *next;
    while (current != NULL) {
        next = current->next;
        freeSymbolInfo(current);
        current = next;
    }
    ctx->symbolTableHead = NULL;
    ctx->errorCount = 0;
    freeErrorList(ctx);
}


// Add symbol to table (simple linked list, checks for duplicates)
// Returns the added symbol or NULL if an error occurred
SymbolInfo* addSymbol(SemanticContext *ctx, VariableName name, ElementType type, ListInt listInt, SymbolKind kind) {
    // Check for duplicates
    if (findSymbol(ctx, name)) {
        // reportError(ctx, "Duplicate variable declaration: %s", name);
        addError(ctx, (VNNLibError) {
            .message = "Duplicate variable declaration",
            .offendingSymbol = name,
            .hint = "Variable names must be unique within the VNNLib file.",
            .errorCode = MultipleDeclaration
        });
        return NULL;
    }

    SymbolInfo *newSymbol = malloc(sizeof(SymbolInfo));
    int *symbolShape = malloc(sizeof(int) * MAX_DIMENSIONS);
    if (!newSymbol || !symbolShape) {
        perror("Failed to allocate memory for symbol info");
        free_safe(newSymbol);
        free_safe(symbolShape);
        return NULL;
    }

    int numDimensions = 0;
    if (listInt && checkListInt(listInt, ctx, symbolShape, &numDimensions) != 0) {
        free_safe(symbolShape);
        free_safe(newSymbol);
        return NULL;
    }

    // Duplicate variable name
    char *nameCopy = strdup_safe(name);

    // Populate symbol info
    newSymbol->name = nameCopy;
    newSymbol->type = type;
    newSymbol->kind = kind;
    newSymbol->shape = symbolShape;
    newSymbol->numDimensions = numDimensions;

    // Add to front of symbol table
    newSymbol->next = ctx->symbolTableHead;
    ctx->symbolTableHead = newSymbol;

    return newSymbol;
}


// Find symbol by name
SymbolInfo* findSymbol(SemanticContext *ctx, VariableName name) {
    if (!ctx || !name || !ctx->symbolTableHead) return NULL;
    SymbolInfo *current = ctx->symbolTableHead;
    while (current != NULL) {
        if (strcmp(current->name, name) == 0) {
            return current;
        }
        current = current->next;
    }
    return NULL; // Not found
}


// ----------------- Recursive Traversal Functions -----------------

// Check the ListInt production and add each discovered Int to the provided shape array
int checkListInt(ListInt p, SemanticContext *ctx, int *shape, int *shapeSize)
{
    if (!p) return 0;  // ListInt is optional
    int err = 0; 
    while(p != 0 && err == 0)
    {
        err |= checkInt(p->int_, ctx);

        if (err) {
            fprintf(stderr, "Unexpected Error in ListInt: %s\n", p->int_);
            return 1;
        } 
        
        if (*shapeSize >= MAX_DIMENSIONS) {
            fprintf(stderr, "Error: Too many dimensions in ListInt.\n");
            return 1;
        }

        shape[*shapeSize] = strtol(p->int_, NULL, 10); // Convert string to int
        p = p->listint_;
        (*shapeSize)++;
    }
    return err; // Propagate error if any check failed.
}


int checkArithExpr(ArithExpr p, SemanticContext *ctx)
{
    if (!p) return 1;
    int err = 0;
    switch(p->kind)
    {
        // TODO: Add type checking to ensure that the operands are of the same type
        case is_VarExpr:
            err |= checkTensorElement(p->u.varexpr_.tensorelement_, ctx);
            break;
        case is_DoubleExpr:
            err |= checkSDouble(p->u.doubleexpr_.sdouble_, ctx);
            break;
        case is_SIntExpr:
            err |= checkSInt(p->u.sintexpr_.sint_, ctx);
            break;
        case is_IntExpr:
            err |= checkInt(p->u.intexpr_.int_, ctx);
            break;
        case is_Negate:
            err |= checkArithExpr(p->u.negate_.arithexpr_, ctx);
            break;
        case is_Plus:
            err |= checkListArithExpr(p->u.plus_.listarithexpr_, ctx);
            break;
        case is_Minus:
            err |= checkArithExpr(p->u.minus_.arithexpr_, ctx);
            err |= checkListArithExpr(p->u.minus_.listarithexpr_, ctx);
            break;
        case is_Multiply:
            err |= checkListArithExpr(p->u.multiply_.listarithexpr_, ctx);
            break;

        default:
            fprintf(stderr, "Bad kind field in ArithExpr node.\n");
            return 1; // Error
    }
    return err; // Propagate error if any check failed
}


int checkListArithExpr(ListArithExpr p, SemanticContext *ctx)
{
    if (!p) return 1;
    int err = 0;
    while(p != 0 && err == 0)
    {
        err |= checkArithExpr(p->arithexpr_, ctx);
        p = p->listarithexpr_;
    }
    return err;
}


int checkBoolExpr(BoolExpr p, SemanticContext *ctx)
{
    if (!p) return 1;
    int err = 0;
    switch(p->kind)
    {
        // TODO: Check number of inputs is >= 2 and return warning if not

        case is_GreaterThan:
            err |= checkArithExpr(p->u.greaterthan_.arithexpr_1, ctx);
            err |= checkArithExpr(p->u.greaterthan_.arithexpr_2, ctx);
            break;
        case is_LessThan:
            err |= checkArithExpr(p->u.lessthan_.arithexpr_1, ctx);
            err |= checkArithExpr(p->u.lessthan_.arithexpr_2, ctx);
            break;
        case is_GreaterEqual:
            err |= checkArithExpr(p->u.greaterequal_.arithexpr_1, ctx);
            err |= checkArithExpr(p->u.greaterequal_.arithexpr_2, ctx);
            break;
        case is_LessEqual:
            err |= checkArithExpr(p->u.lessequal_.arithexpr_1, ctx);
            err |= checkArithExpr(p->u.lessequal_.arithexpr_2, ctx);
            break;
        case is_NotEqual:
            err |= checkArithExpr(p->u.notequal_.arithexpr_1, ctx);
            err |= checkArithExpr(p->u.notequal_.arithexpr_2, ctx);
            break;
        case is_Equal:
            err |= checkArithExpr(p->u.equal_.arithexpr_1, ctx);
            err |= checkArithExpr(p->u.equal_.arithexpr_2, ctx);
            break;

        case is_And:
            err |= checkListBoolExpr(p->u.and_.listboolexpr_, ctx);
            break;
        case is_Or:
            err |= checkListBoolExpr(p->u.or_.listboolexpr_, ctx);
            break;

        default:
			fprintf(stderr, "Bad kind field in BoolExpr node.\n");
			return 1;
    }
	return err;
}


int checkListBoolExpr(ListBoolExpr p, SemanticContext *ctx)
{
    if (!p) return 1;
    int err = 0;
    while(p != 0 && err == 0)
    {
        err |= checkBoolExpr(p->boolexpr_, ctx);
        p = p->listboolexpr_;
    }
    return err;
}


int checkProperty(Property p, SemanticContext *ctx)
{
    if (!p) return 1;
    int err = 0;
    switch(p->kind)
    {
        case is_Prop:
            err |= checkBoolExpr(p->u.prop_.boolexpr_, ctx);
            break;

        default:
			fprintf(stderr, "Bad kind field in Property node.\n");
			return 1;
    }
    return err;
}


int checkListProperty(ListProperty p, SemanticContext *ctx)
{
    if (!p) return 1;
    int err = 0;
    while(p != 0)
    {
        err |= checkProperty(p->property_, ctx);
        p = p->listproperty_;
    }
    return err;
}


int checkElementType(ElementType p, SemanticContext *ctx)
{
    if (!p) return 1;
	switch(p->kind)
	{
        case is_GenericElementType: break;
        case is_ElementTypeF16: break;
        // ... all other cases ... (Shortened for brevity)
        case is_ElementTypeString: break;

        default:
            fprintf(stderr, "Bad kind field in ElementType node.\n");
            return 1; 
	}
	return 0; 
}


int checkInputDefinition(InputDefinition p, SemanticContext *ctx)
{
    if (!p) return 1;
    int err = 0;
    switch(p->kind)
    {
        case is_InputDef:
            err |= checkVariableName(p->u.inputdef_.variablename_, ctx);
            err |= checkElementType(p->u.inputdef_.elementtype_, ctx);
            if (err) return err; // Don't proceed if children have errors

            // Check for duplicate symbols
            if (!addSymbol(ctx, p->u.inputdef_.variablename_, p->u.inputdef_.elementtype_, p->u.inputdef_.listint_, SYM_INPUT)) {
                err = 1; 
            }
            break;

        default:
            fprintf(stderr, "Bad kind field in InputDefinition node.\n");
            return 1; 
    }
    return err;
}


int checkHiddenDefinition(HiddenDefinition p, SemanticContext *ctx)
{
    if (!p) return 1;
	int err = 0;
	switch(p->kind)
	{
        case is_HiddenDef:
            err |= checkVariableName(p->u.hiddendef_.variablename_, ctx);
            err |= checkElementType(p->u.hiddendef_.elementtype_, ctx);
            err |= checkString(p->u.hiddendef_.string_, ctx);
            if (err) return err;

            // Check for duplicate symbols
            if (!addSymbol(ctx, p->u.hiddendef_.variablename_, p->u.hiddendef_.elementtype_, p->u.hiddendef_.listint_, SYM_INTERMEDIATE)) {
                err = 1;
            }
            break;

        default:
			fprintf(stderr, "Bad kind field in HiddenDefinition node.\n");
			return 1;
	}
	return err;
}


int checkOutputDefinition(OutputDefinition p, SemanticContext *ctx)
{
    if (!p) return 1;
	int err = 0;
	switch(p->kind)
	{
        case is_OutputDef:
            err |= checkVariableName(p->u.outputdef_.variablename_, ctx);
            err |= checkElementType(p->u.outputdef_.elementtype_, ctx);
            if (err) return err;

            // Check for duplicate symbols
            if (!addSymbol(ctx, p->u.outputdef_.variablename_, p->u.outputdef_.elementtype_, p->u.outputdef_.listint_, SYM_OUTPUT)) {
                err = 1;
            }
            break;

        default:
            fprintf(stderr, "Bad kind field in OutputDefinition node.\n");
            return 1; // Error
	}
	return err;
}


int checkListInputDefinition(ListInputDefinition p, SemanticContext *ctx)
{	
    if (!p) return 1;
    int err = 0;
    while(p != 0)
    {
        err |= checkInputDefinition(p->inputdefinition_, ctx);
        p = p->listinputdefinition_;
    }
    return err;
}


int checkListHiddenDefinition(ListHiddenDefinition p, SemanticContext *ctx)
{
	if (!p) return 0; // ListHiddenDefinition is optional
    int err = 0;
    while(p != 0)
    {
        err |= checkHiddenDefinition(p->hiddendefinition_, ctx);
        p = p->listhiddendefinition_;
    }
    return err;
}


int checkListOutputDefinition(ListOutputDefinition p, SemanticContext *ctx)
{
    if (!p) return 1;
    int err = 0;
    while(p  != 0 && err == 0)
    {
        err |= checkOutputDefinition(p->outputdefinition_, ctx);
        p = p->listoutputdefinition_;
    }
    return err;
}


int checkNetworkDefinition(NetworkDefinition p, SemanticContext *ctx)
{
    if (!p) return 1;
	int err = 0;
	switch(p->kind)
	{
        case is_NetworkDef:
            // TODO: Store context of network: ctx->currentNetwork = p->u.networkdef_.variablename_;

            err |= checkVariableName(p->u.networkdef_.variablename_, ctx);

            // Process definitions - this populates the symbol table
            err |= checkListInputDefinition(p->u.networkdef_.listinputdefinition_, ctx);
            err |= checkListHiddenDefinition(p->u.networkdef_.listhiddendefinition_, ctx);
            err |= checkListOutputDefinition(p->u.networkdef_.listoutputdefinition_, ctx);
            break;

        default:
            fprintf(stderr, "Bad kind field in NetworkDefinition node.\n");
            return 1; 
	}
	return err;
}


int checkListNetworkDefinition(ListNetworkDefinition p, SemanticContext *ctx)
{
    if (!p) return 1;
    int err = 0;
    while(p != 0)
    {
        err |= checkNetworkDefinition(p->networkdefinition_, ctx);
        p = p->listnetworkdefinition_;
    }
    return err;
}


int checkQuery(Query p, SemanticContext *ctx)
{
    if (!p) return 1;
    int err = 0;
    switch(p->kind)
    {
    case is_VNNLibQuery:
        // 1. Process network definitions (populates symbol table)
        err |= checkListNetworkDefinition(p->u.vnnlibquery_.listnetworkdefinition_, ctx);

        // 2. Process properties (uses symbol table for checks)
        err |= checkListProperty(p->u.vnnlibquery_.listproperty_, ctx);
        break;

    default:
        fprintf(stderr, "Bad kind field in Query node.\n");
        return 1; // Error
    }
    return err;
}


// --- Base Type Checkers ---

int checkSDouble(SDouble p, SemanticContext *ctx) { return 0; }
int checkSInt(SInt p, SemanticContext *ctx) { return 0; }
int checkInt(Int p, SemanticContext *ctx) { return 0; }
int checkVariableName(VariableName p, SemanticContext *ctx) { return 0; }
int checkIdent(Ident i, SemanticContext *ctx) { return 0; }      
int checkInteger(Integer i, SemanticContext *ctx) { return 0; }
int checkDouble(Double d, SemanticContext *ctx) { return 0; }
int checkChar(Char c, SemanticContext *ctx) { return 0; }
int checkString(String s, SemanticContext *ctx) { return 0; }


int checkScalar(SymbolInfo *symbol, TensorElement element, SemanticContext *ctx, char *tensorDim) {
    int index = strtol(tensorDim, NULL, 10);
    if (index != 0) {
        addError(ctx, (VNNLibError) {
            .message = "Invalid tensor element",
            .offendingSymbol = element,
            .hint = "Expected dummy index 0 for scalar variable.",
            .errorCode = NotEnoughIndices
        });
        return 1;
    }
    return 0;
}


int checkTensor(SymbolInfo *symbol, TensorElement element, SemanticContext *ctx, char *tensorDim) {
    int err = 0;
    int *indices = malloc(sizeof(int) * symbol->numDimensions);
    int idx = 0;
    char *token;

    // Check that the correct number of indices are provided
    token = strtok(tensorDim, "-");

    while (idx < symbol->numDimensions) {
        if (token == NULL) {
            err = 1;
            addError(ctx, (VNNLibError) {
                .message = "Not enough indices provided",
                .offendingSymbol = element,
                .hint = format_string("Expected %d indices but encountered %d.", symbol->numDimensions, idx),
                .errorCode = NotEnoughIndices
            });
            goto cleanup;
        }

        indices[idx] = strtol(token, NULL, 10);
        idx++;
        token = strtok(NULL, "-");
    }

    if (token != NULL) {
        err = 1;
        addError(ctx, (VNNLibError) {
            .message = "Too many indices provided",
            .offendingSymbol = element,
            .hint = format_string("Expected %d indices but encountered %d.", symbol->numDimensions, idx + 1),
            .errorCode = TooManyIndices
        });
        goto cleanup;
    }

    // Check that indices are within bounds
    for (int i = 0; i < symbol->numDimensions; i++) {
        if (indices[i] < 0 || indices[i] >= symbol->shape[i]) {
            err = 1;
            // reportError(ctx, "Index out of bounds: %d for dimension %d", indices[i], i);
            addError(ctx, (VNNLibError) {
                .message = "Index out of bounds",
                .offendingSymbol = element,
                .hint = format_string("Expected index in range [0, %d), but got %d.", symbol->shape[i], indices[i]),
                .errorCode = IndexOutOfBounds
            });
        }
    }

    cleanup:
        free_safe(indices);
        return err;
}


// Checks usage of tensor elements
int checkTensorElement(TensorElement p, SemanticContext *ctx) {
    if (!p) return 1;
    int err = 0;

    // Extract the tensor name and dimension from the string
    char *tensorName = strdup_safe(p);
	char *tensorDim = strchr(tensorName, '_');
    *tensorDim = '\0'; // Terminate the variable name
    tensorDim = tensorDim ? tensorDim + 1 : NULL; 

    // Check that the tensor indices are provided
    if (!tensorDim) {
        err = 1;
        addError(ctx, (VNNLibError) {
            .message = "Invalid tensor element",
            .offendingSymbol = p,
            .hint = "Expected format: <tensor>_<index>",
            .errorCode = NotEnoughIndices
        });
        goto cleanup;
    }

    SymbolInfo *symbol = findSymbol(ctx, tensorName); 

    // Check that variable is declared
    if (!symbol) {
        err = 1;
        addError(ctx, (VNNLibError) {
            .message = "Undeclared variable",
            .offendingSymbol = tensorName,
            .hint = "Variable must be declared before use.",
            .errorCode = UndeclaredVariable
        });
    }

    // Check that index is 0 for scalar variables
    else if (symbol->numDimensions == 0) {
        err |= checkScalar(symbol, p, ctx, tensorDim);
    }

    // Check that indices are valid for tensor variables
    else {
        err |= checkTensor(symbol, p, ctx, tensorDim);
    }

    cleanup:
        free_safe(tensorName);
        return err;  
}